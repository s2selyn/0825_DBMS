/*
 * < TCL : TRANSACTION CONTROL LANGUAGE >
 * 트랜잭션 제어 언어
 * 
 * ☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★
 * ☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★
 * ☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★
 * ☆★☆★☆★☆★☆★☆★☆★☆★생각이 필요한 개념☆★☆★☆★☆★☆★☆★☆★☆★☆★
 * 
 * 유일하게 DB단에서 생각해야하는거, 앞에는 다 보고쓰는거, 이거는 생각해야하는거
 * 
 * * TRANSACTION
 * - 작업단위
 * - 데이터베이스의 상태를 변화시키는 논리적 연산단위
 * - 여러개의 DML구문을 하나로 묶어 처리하는 메커니즘
 * - 데이터의 변경사항(DML)들을 하나의 트랜잭션으로 묶어서 관리( SELECT는 데이터의 트랜잭션에 포함되지 않음! )
 *   COMMIT(확정)하기 전까지의 변동사항들을 하나의 트랜잭션에 담게됨
 * - 트랜잭션의 대상이 되는 SQL : INSERT, UPDATE, DELETE
 * 
 * * TRANSACTION의 4가지 속성
 * 
 * ACID(줄여서 흔히 ACID라고 함)
 * 
 * 1. Atomicity(원자성) : 트랜잭션 내의 모든 작업은 전부 수행되거나,
 * 						 전혀 수행되지 않아야한다. 라는 원칙(될거면 싹다 커밋, 안될거면 싹다 롤백)
 * 
 * 2. Consistency(일관성) : 트랜잭션이 성공적으로 완료 된 후에도
 * 						 데이터베이스는 유효한 상태를 유지해야한다는 원칙
 * (테이블 관련된 얘기, 테이블 만들면서 제약조건 달았음, 트랜잭션 수행했는데 제약조건 위배되면 안됨, 데이터타입이나 크기도 마찬가지, 데이터 무결성이 깨져서는 안된다, 테이블의 상태가 똑같아야한다)
 * 
 * 3. Isolateion(고립성) : 동시에 실행되는 여러 트랜잭션이 상호간에 영향을 끼치지
 * 						 않도록 하는 원칙
 * (우리랑 지금 단계에서는 연관이 없는데, 트랜잭션이 수행되는데 여러명의 사용자가 동시에 DB를 사용함,
 * 이 트랜잭션이 다른 트랜잭션이 영향을 끼치면 안되고 독립적으로 해야함, 둘이 동시에 작업해서 서로 영향을 주면 안되니까 누가 작업하면 다른사람은 대기시켜놓고, 작업이 끝나면 할수있게해줘야함)
 * 
 * 4. Durablity(지속성) : 트랜잭션이 성공적으로 수행되었다면,
 * 						시스템에 문제가 발생하더라도 영구적으로 반영이 되어야한다.
 * (바깥쪽 얘기, 커밋해서 성공했는데 지진나서 와장창 천둥치고 난리나도 트랜잭션해서 반영된건 유지되어야함)
 * 
 * COMMIT(트랜잭션을 종료 처리 후 확정), ROLLBACK(트랜잭션 취소), SAVEPOINT
 * 
 * DML을 수행하면 무조건 롤백이나 커밋 둘중에 하나를 수행해야함
 * 세상이 좋아져서.. 우리가 오토 커밋을 껐잖아요? 디폴트가 체크되어있었음.. DML 하는순간 얘가 커밋을 바로바로 해버림, 그래서 어제 롤백못한것
 * 앞으로 계속 오토커밋 켜놓고 할건데.. 트랜잭션으로 묶어서 처리해야 하는 상황들이 있단말이야, 롤백시켜야하는 상황이면 직접 트랜잭션 관리할거고, 그게아니면 오토커밋 켜놓을거고??
 * 
 * 현실세계의 아무거나에 이거 갖다붙일 수 있음, 계좌이체로 해보자
 * 핸드폰 어플이라고 하면 이건 은행 프로그램을 이용하는거겠지
 * 계좌이체라는 작업을 할 때 많은 작업이 일어남
 * 일반적인 상황(선생님이 생각하는 계좌이체)을 가정해보자
 * 선생님이 계좌이체를 하려면 핸드폰에서 은행 어플을 열어
 * 그럼 아마 이런 작업이 일어나겠지
 * 1. 인증 단계 : 선생님은 은행어플이 세네개를 쓰심. 카카오 우리 기업 강남? 네개다 지문내놓으라고함, 항상 열면 사용자인증부터시작(핸드폰에 있는 지문센서랑 은행 API랑 연계되어서 어쩌구저쩌구 되겠지)
 * 1을 통과해야 그다음단계로 넘어갈수있음... 근데 이거 얘기하면 너무 길어지니까 인증 했다고 치자
 * 2. SELECT -> 통장잔고가 보임, 이거 보여주려면 은행 DB에 있는 계좌 테이블에서 인증한 사람 식별자가 왔으니까 이사람의 잔고를 SELECT해서 응답해주겠지
 * 핸드폰 안에 잔고정보가 있는게아니라 은행서버에 있는정보. 이걸 화면에 보여줌(인증하면서도 SELECT 일어났겠지만 이건 생략하고 잔고 SELECT먼저 한다고 침)
 * 3. 계좌이체 하려면 계좌이체 할 수 있는 화면이 나오겠지, 뜬금없이 입력하는거 주고 밑에 버튼들 있음, 얼마할지, 5만원 입력함
 * 4. 금액 입력했더니 은행 고르라고 함, 은행 목록이 나오는데 여기서 SELECT가 또 일어남, 은행의 목록은 가변적인 내용, 새로운 은행이 생길수도 있고 2~3 금융권.. 이것도 은행 테이블로 DB에 저장되어 있겠지
 * 사용자가 이상한 은행 입력하면 안되니까 우리 DB에 존재하는 은행의 정보를 SELECT 해오겠지
 * 5. 은행 골랐당, 카뱅 골랐다고 치자, 이랬더니 계좌번호 쓰라고함, 어디다 보낼건지(뭐 최근입금 자주입금 이런것도 조회하겠지만 그건 넘기자)
 * 6. 다 입력했으면 확인버튼 누르겠죠? 그다음엔 니가 보내려고 하는데가 이게맞니? 라고 확인시켜줌, 은행, 계좌, 누구누구임, 얼마보내는거임 --> 누구누구임을 뽑아내려고 SELECT 또 했겠지
 * 7. 확인했으니까 확인 버튼 누르면 또 지문 내놓으라고 함, 권한체크(인가) 하는거지, 로그인 해놓고 자리비운사이에 누가와서 하면 곤란하니까.. 이거도 걍 설명 스킵함
 * 
 * SELECT를 했는데, 돈 보내기 전까지 실제로 계좌이체가 진행된것은 아님
 * 은행 테이블에 있는 데이터의 변경도 일어나지 않음
 * 계좌이체 기능만 놓고 보면 계좌에 대한 정보가 바뀐게 없음
 * 트랜잭션은 계좌이체를 시도하기까지 많은 절차가 있었는데 여기까진 트랜잭션이랑 아무 상관이 없고
 * 이 이후부터 관련있음
 * 
 * 최종 확인을 누른 시점에 보내려는 돈이 남아있는지 일단 확인해야함
 * 1. 금액 SELECT 함, 했더니 보낼 수 있는 금액이 남아있다면?
 * 2. 통장 잔고를 갱신해줘야함 -> -50000 UPDATE
 * 3. 상대방 계좌도 바뀌어야함 -> +50000 UPDATE
 * 4. UPDATE된 결과를 SELECT해서 보여줘야함
 * 여기까지 해야 계좌이체가 완료됨
 * 
 * 그래야 상대방이 들어가자마자 SELECT 했을때 잔고가 +5만 된게 보이겠지
 * 
 * 만약에 2번에서 은행이 정전됨.. 동시에 2 3이 일어날 수 없음.. 그럼 3은 정전때문에 안일어나.. 그럼 선생님 억울해 뒤짐 ㅜㅜ
 * 
 * 아니면 확인을 누르기 직전에 돈을 뽑아서 2번은 실패함, 계좌이체 절차에 의해서 3은 수행되어버림.. 그럼 선생님 기분조와~
 * 
 * 이런 일은 발생하면 안되잖아여...
 * 
 * 2는 되고 3이 안됐다면? 2를 취소시켜야함
 * 3은 되고 2가 안됐다면? 3이 취소되어야함
 * 
 * 될거면 둘다 안되고, 하나 실패하면 하나 되돌려야하고.. 기능마다 묶어야하는 작업단위들이 있게됨
 * 
 * 게시글 작성이라는 기능을 만든다고 치자, 파일 첨부하는 기능을 구현했다면 게시글도 작성하고 파일도 첨부할수있게됨
 * 두개의 테이블에 INSERT를 하겠지, 게시글 테이블과 파일 테이블
 * 게시글 INSERT를 실패함, 제약조건 안맞아서.. 근데 파일은 INSERT됨.. 그럼 의미없죠? 둘다 실패해야함
 * 게시글은 올라가고 파일은 실패함.. 이건 내가 생각했을때 게시글은 남겨도 될 것 같은데? 그럼 파일은 실패해도 되겠지?
 * 
 * 아무튼 개발자가 생각했을 때 묶여야하는 연산단위를 트랜잭션이라고함
 * 정답이 정해져있는게 아니고 만드는 사람이 생각하는것, 이런것들이 하나의 트랜잭션으로 묶여야겠다, 이런것들은 분리를 해야겠다 이런식으로
 * 
 * 많은 개발자들이 정형화해서 사용하는것들이 있지만 뭐 내생각이 다르면 내생각대로 만들면 되고.. 정답이 없는 문제
 * 좋은 예제는 있고 괜찮은 방법은 존재하지만 무조건 그게 올바른것은 아님
 * 
 */

CREATE TABLE EMP_COPY
    AS SELECT EMP_ID, EMP_NAME FROM EMPLOYEE;

SELECT * FROM EMP_COPY;

-- 사번이 900번인 사원 삭제
DELETE
  FROM
       EMP_COPY
 WHERE
       EMP_ID = 900;

SELECT * FROM EMP_COPY;

-- 사번이 222번인 사원 삭제
DELETE
  FROM
       EMP_COPY
 WHERE
       EMP_ID = 222;

SELECT * FROM EMP_COPY;

ROLLBACK;

SELECT * FROM EMP_COPY; -- DELETE 했던 두개 다 살아남

-- DELETE 할때 조건 안달면?
DELETE
  FROM
       EMP_COPY;

-- 그리고 다시 돌려돌려 하면?
ROLLBACK;

SELECT * FROM EMP_COPY; -- 싹 살아남

-- SELECT는 트랜잭션이랑 실질적으로 관계가 없음(개념적으로 포함시킬수는 있겠지만????????????)
-- DELETE문을 수행하면? 수행하는 순간 트랜잭션이 생김
-- 데이터의 변동이 일어나는 SQL을 작성(수행?)하면 트랜잭션이 생기면서 이 안에 첫번째 DELETE문이 들어감
-- 그리고 두번째 DELETE를 수행하면, 이미 만들어진 트랜젝션에 두번째 DELETE문이 들어감
-- 이 상태에서 ROLLBACK;을 하면, 기존에 만들어진 트랜잭션에 들어가있던애들이랑 다같이 날아감
-- 롤백은 트랜잭션 통째로 안에 포함된 애들을 싹 날려버림

--------------------------------------------------

SELECT * FROM EMP_COPY; -- 트랜잭션 아직 안생김, SELECT로는 트랜잭션이 생기지 않어요

DELETE FROM EMP_COPY WHERE EMP_ID = 900; -- 이걸 빵때리면 900이 날아감, 트랜잭션 생성된 상황
-- 트랜잭션이 만들어지고 안에 이 DELETE가 들어감
-- 이 이후에 일어나는 DML 작업들은 여기에 다 묶여버림, UPDATE, INSERT 다
UPDATE EMP_COPY SET EMP_NAME = '홍길동' WHERE EMP_NAME = '고길동';
-- 이거 실행하면 아까 생긴 트랜잭션에 또 이게 들어감

-- SELECT 해도 트랜잭션에 들어가지는 않음
SELECT * FROM EMP_COPY;

-- 롤백 아까 해봤으니 커밋ㄱㄱ
COMMIT; -- 이거 하고 나면 일어나는 일이 없음

SELECT * FROM EMP_COPY;

ROLLBACK; -- 커밋하고나서 롤백하면? 백날천날 해봤자 900번이 살아돌아오지않음...

SELECT * FROM EMP_COPY;
-- 홍길동도 돌아오지 않음..

-- 커밋을 하면 트랜잭션에 올라가있던 친구들을 확정짓는다고 표현
-- 이론적으로는 확정짓는다고 하는데 실제로는 얘를 그냥 저장장치에 저장하는걸 말함, 물리적인 저장장치에 저장하는것
-- 모든 작업이 마찬가지, 예를 들어서 TABLE이라는 파일이 있다고 가정
-- 여기서 이런저런 작업을 막 할거아니에요? 데이터를 새롭게 쓰고, 기존에 있던 데이터를 수정도 하고, 있는 데이터를 지우기도 하고
-- 내가 이렇게 작업한걸 확정지으려면? 저장이라는 작업을 해야함. 내 컴퓨터(물리적인 저장장치)에 기록하는 것이 저장
-- 저장하고 나서 수정을 막 해, 이런걸 하고 반영안하고 싶으면? 그냥 꺼버림 저장안하고 끄면그만, 그러면 작업했던거 없어짐
-- 파일에 작업하는게 DML, 저장안하고싶으면 날리는게 롤백, 작업을 열심히 한 다음에 확정짓는게 저장인데(메모리에 있는걸 물리장치에 넣는거) 이게 커밋
-- 이거랑 똑같은 개념이다

--------------------------------------------------

-- 사번이 214, 216번인 사원삭제
DELETE
  FROM
       EMP_COPY
 WHERE
       EMP_ID IN (214, 216); -- UPDATED ROWS 2
-- 트랜잭션 생성되고 이 DELETE가 포함됨

-- 2개 행이 삭제된 시점에 SAVEPOINT 지정
SAVEPOINT DELETE2ROWS;
-- 트랜잭션 밑에 줄그어서 구분됨

SELECT * FROM EMP_COPY;

-- 이 이후에 DELETE를 또 써
DELETE
  FROM
       EMP_COPY
 WHERE
       EMP_ID = 222;
-- 이게 또 기존 트랜잭션에 포함됨
-- 이상태에서 롤백하면 어떻게됨? 트랜잭션 ㅂㅂ하고 날아가겠지?
-- 롤백할때 지정한 세이브포인트로 롤백할수있음
ROLLBACK TO DELETE2ROWS; -- 그냥 롤백하면 214 216 222 다 돌아옴
-- 세이브포인트 지정하면 214 216은 날아간 상태고 홍길동만 살릴 수 있음

SELECT * FROM EMP_COPY; -- 세이브 포인트
ROLLBACK; -- 이건 완전 롤백, 214, 216 다돌아옴

--------------------------------------------------

-- 집에서 공부 막 해...
COMMIT;

DELETE FROM EMP_COPY WHERE EMP_ID = 222;

SELECT * FROM EMP_COPY;

CREATE TABLE HAHA(
	HID NUMBER
);

ROLLBACK;
-- 죽은 홍길동이 살아나야함, 근데 안돌아옴
-- 롤백을 해서 돌아가는 시점은 언제임? 마지막 커밋에 성공한 시점으로 돌아감
-- 실질적으로 커밋을 하고 DELETE 했음, 그럼 DELETE 하기 전으로 돌아가야하는데.. 실제로 커밋이 수행된게 어디서 수행됨? 테이블 생성 시점에 수행됨
-- 공통...! 공부할 때 조심해야 하는 내용
/*
 * DDL 구문(CREATE, ALTER, DROP)을 수행하는 순간
 * 트랜잭션에 있는 모든 작업사항을 무조건 COMMIT해서 실제 DB에 반영 한 후 DDL을 수행
 * --> DDL을 써야하는데 이전 트랜잭션이 존재한다 ==> COMMIT / ROLLBACK 수행 후 처리
 * 
 */