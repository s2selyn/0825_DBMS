-- 주석문 : 한 줄 주석을 적을 때는 이렇게 씁니다.
/*
	여러 줄 주석을 사용할 땐 이렇게 씁니다.
*/

-- 실제 DB에 데이터를 지금 많이 만들어둔 상태! 이걸 조회하는 문법을 배워보자

/*
 * <SELECT>
 * 데이터를 조회하거나 검색할 때 사용하는 명령어
 * 테이블은 데이터가 들어가는 표 형태, 엑셀의 시트같은 모양
 * 
 * [ 표현법 ]
 * SELECT
 * 		  조회하고자 하는 컬럼
 * 	    , 조회하고자 하는 컬럼
 * 		, 조회하고자 하는 컬럼
 * 	 FROM
 * 		  테이블명;
 * 
 * 제일 위에 있는 머리줄행에 이름이 달려있음, 이 이름을 컬럼명이라고 함
 * 각각의 컬럼이 어떤 의미를 가진 컬럼인지를 의미하는 컬럼명!
 * 조회할때는 내가 데이터를 조회하고 싶은 컬럼명을 적음. 여러개 적어도됨
 * 그다음 무조건 FROM절이 오는데 이다음에 테이블이름을 씀
 * 어떤 테이블에서 이 컬럼들을 조회하고싶은지
 * 
 * 이렇게 하면 조회가 됨
 * 조회된 결과가 행단위로 조회가됨
 * 지금 총 23행이 조회된 것
 * 
 * SELECT문의 결과는 행 단위로 조회됨
 * 
 * - ResultSet : 조회된 행들의 집합 // SELECT문을 통해 조회된 데이터 결과물을 의미함
 * 결과는 ResultSet이 돌아온것이다~
 * 
 */

/*
 * 왼쪽에 접속된 것을 열어서 Schemas 열어보기
 * 그중에 내 계정! CJ18 화살표 눌러서 열어보기
 * Tables 있음 열어보기
 * 너무 오래걸려서 취소함ㅎ
 * 
 */

-- 우리가 KH 그룹의 사원이라고 가정하고 Employee라는 표를 만들어서 사원의 정보를 저장함
-- Employee 테이블의 데이터를 조회해보자
SELECT * FROM EMPLOYEE; -- 이 방법은 사용해선 안됨
-- 이것은 EMPLOYEE 테이블에 있는 모든 컬럼을 조회하겠다는 의미로 씀
-- EMPLOYEE테이블에서 모든 컬럼을 전부 다 조회하겠다.
-- * <-- 얘가 모든 컬럼이라는 의미를 가짐
-- 이렇게 하면 안되고, 이걸 하고싶었으면 컬럼명을 하나하나 전부 적었어야함
-- 이렇게 셀렉문을 날리면 연산을 처리할 때 컬럼이 뭐있지? 하는 연산이 추가로 들어감
-- 한 행을 조회할때는 상관없지만 만행정도 가면 부하가 걸려서 성능에 영향을 주게 됨
-- * 사용 시 성능에 영향을 끼침
-- IT업계에서도 소프트웨어를 다 만들고나면 감리가 나옴, 감리사분들이 나와서 만들어진걸로 감리를 하는데, 이런게 들어있으면 도장을 못받음(성능최적화가 제대로 안되어있다고), 납품을 못함
-- 공부할때야 상관없지만 실제로 무언가를 만들고 작업할때는 절대로 쓰면 안됨!
-- 소소하지만 중요한것들~ 조금씩 하면서 추가로 설명하실 예정

-- 12:00 저장되어 있는 데이터를 확인 하는 방법을 알아봤는데,
-- 사원의 정보를 저장하는 EMPLOYEE라는 테이블에 이만~큼의 데이터가 저장되어 있음
/*
 * 한 줄당 한행이라고 표현함, 한 행이 한명의 사원에 대한 정보를 저장하고 있다
 * 우리반 20명? 선생님이 한명 빼먹으심ㅎ 나중에 INSERT문 할때 넣어드리겠습니다^^
 * 이렇게 들어가 있는 데이터를 조회하는 방법부터 학습해봅시다
 * 
 */

-- 사원명, 이메일, 급여를 조회해야겠다!
-- 사원명은 EMP_NAME, 이메일은 EMAIL, 급여는 SALALY 컬럼에 있음, 세개의 컬럼값만 조회하고싶음
SELECT
	   EMP_NAME
	 , EMAIL
	 , SALARY -- 조회하고 싶은 컬럼명을 쉼표(,)로 구분
  FROM
  	   EMPLOYEE;

-- 돌아오는 결과를 ResultSet이라고 해요~

-- 웬만하면 이렇게 한줄로, 소문자로 적어도 돌아감(너무 좋은 도구를 써버리네~)
SELECT emp_name, email, salary FROM employee;

-- 웬만하면 위에서 쓰는 것처럼 쓰는 것을 권장!
-- 키워드, 테이블, 컬럼명의 대소문자 구분 없이 써도 되고, 줄 나누기도 상관없지만 보기좋아서!
-- 예를 들어서 수정이 필요할 때 한줄을 통째로 지워버리면 가능함
-- 한줄에 다 들어있으면 구분이 힘들 수 있음
-- 갈색은 키워드, 키워드랑 컬럼명/테이블식별자를 구별하기 위해서 왼쪽 오른쪽으로 나눠서 적는 것을 권장함
-- 중요한 것은 키워드 파트랑 컬럼명 파트를 나눠놓은 가운데 라인이 비어야함!
-- 탭 말고 스페이스로 맞추기, 익숙해지면 나중에 탭
-- 명령어, 키워드, 테이블명, 컬럼명은 대/소문자를 가리지않음
-- 소문자로 작성을해도 잘 동작을 하지만 대문자로 작성하는 습관을 들이는것이 좋음
-- SELECT는 내가 테이블에서 무슨 컬럼 조회할지 쓰면 끝

-- SQL은 정해진대로 쓰면 끝

-- 실습문제

-- 1. JOB테이블에서 JOB_CODE, JOB_NAME컬럼을 조회하세요.
SELECT
       JOB_CODE
     , JOB_NAME
  FROM
	   JOB;

-- 2. JOB테이블에서 직급명만 조회되게 SELECT문을 작성해보세요.
SELECT
       JOB_NAME
  FROM
       JOB;

-- 3. DEPARTMENT 테이블에서 DEPT_ID, DEPT_TITLE, LOCATION_ID 컬럼을 조회하세요.
SELECT
       DEPT_ID
	 , DEPT_TITLE
	 , LOCATION_ID
  FROM
  	   DEPARTMENT;

-- 4. EMPLOYEE테이블에서 EMP_NAME, EMAIL, PHONE컬럼을 조회하세요.
SELECT
       EMP_NAME
	 , EMAIL
	 , PHONE
  FROM
       EMPLOYEE;

-- 5. EMPLOYEE테이블에서 HIRE_DATE, EMP_NAME, SALARY컬럼을 조회하세요.
SELECT
       HIRE_DATE
     , EMP_NAME
     , SALARY
  FROM
       EMPLOYEE;

--------------------------------------------------

/*
 * < 컬럼의 조회된 값을 통한 산술연산 >
 * 컬럼들을 나열해서 조회를 할 때 산술연산(+, -, *, /)을 기술해서 결과를 조회할 수 있음
 * 
 */

-- 사원의 정보가 저장되어 있는 EMPLOYEE테이블이 있는데, 여기서 직원명이랑 월급을 조회해보자
-- 직원명은 EMPLOYEE_NAME, 월급은 SALARY에 들어있음
-- EMPLOYEE테이블로부터 직원명, 월급, 연봉(== 월급 X 12)
SELECT
       EMP_NAME
     , SALARY
     , SALARY * 12 + 400000
  FROM
       EMPLOYEE;
-- SELECT의 결과를 RESULTSET이라고 한다!
-- 이걸 조회할 때 연봉을 알고싶은데, 단순히 12를 곱하면 나오겠지? 이걸 SELECT절에 기술할 수 있음
-- SALARY는 숫자(정수값이니까 곱하기 12같은거 가능!)

-- 이렇게 조회할 때 다른식으로 연산한 결과를 같이 조회하는거고, 실제로 SALARY값을 바꾸지는 않음
-- SELECT는 값을 바꿀 수 없음! 조회할때만 사용함

-- EMPLOYEE테이블로부터, 사원명, 월급, 보너스, 보너스를 포함한 연봉(((월급) * 보너스 + 월급) * 12)
SELECT 
       EMP_NAME
     , SALARY
     , BONUS
     , ((SALARY * BONUS + BONUS) * 12) -- 이번에는 보너스가 있으니까, 보너스를 포함한 연봉을 같이 조회하고싶다!
  FROM 
       EMPLOYEE;
-- 이렇게 하면 BONUS에 NULL이 있던 사원은 NULL이 나옴!
--> 산술연산 과정에서 NULL값이 존재할 경우 산술연산의 결과도 NULL이 된다.(당장은 해결 안되는 과제, 오늘 오후나 내일 오전에)

-- DATE => 년, 월, 일, 시, 분, 초
-- 보편적으로 모든 컴퓨터는 정수형으로 지정되어있음, 기준점으로 몇초가 지났는지로 표현해줌
-- DATE 타입끼리의 연산 --> 근무 일수(오늘날짜 - 입사일)
-- 현재 지금 시점의 날짜값 : SYSDATE라는 키워드로 얻을 수 있음
SELECT
       EMP_NAME
     , HIRE_DATE -- 입사일 저장하는 컬럼
     , SYSDATE - HIRE_DATE
  FROM
       EMPLOYEE;
-- 12:44 날짜, 오라클에서는 (??? 타입과), DATE타입으로 날짜를 저장함
-- 결과가 기본적으로 일단위로 나옴, 소수점 아래는 시분초 빼서 나오는 값(숫자와 숫자의 연산이므로)
-- 시분초가 달라지기 때문에 실행할 때 마다 소수점 뒤의 값은 바뀜
-- 결과값은 일 단위 --> 값이 지저분한 이유는 DATE안에는 시/분/초가 포함되어있으므로
-- 시/분/초까지 연산을 수행해서 지저분하게 나옴

-- 컬럼에 산술연산해서 산술연산 결과를 resultset에 포함시키는것까지 해봤고~

--------------------------------------------------

-- 확 쉬워졌당! 이번 주 내내 이거 할거임~ 있는 그대로 받아들이기만 하면 됨

/*
 * < 컬럼명에 별칭 부여하기 >
 * 12:49 테이블 만들 때 붙여둔 컬럼명을 조회할 때 내맘대로 별칭을 붙여서 조회할 수 있음
 * 
 * [ 표현법 ]
 * 컬럼명 AS 별칭, 컬럼명 AS "별칭", 컬럼명 "별칭", 컬럼명 별칭
 * AS 키워드 생략 가능(달아도 되고 안달아도 되고)
 * 별칭에 특수문자 또는 공백문자가 포함될 경우 반드시 ""로 묶어주어야함
 * 
 */

SELECT
       EMP_NAME AS 사원명
     , SALARY "급여 (월)"  -- 쌍따옴표를 달아야 하는 경우가 있음, 특수문자가 들어가면 연산식으로 이해하므로, 띄어쓰기가 들어가는 경우에도 반드시 쌍따옴표로 적어야만 별칭으로 사용 가능
  FROM
       EMPLOYEE;

--------------------------------------------------

-- 리터럴을 사용하는 경우, 추가적으로 상수값을 사용하고싶다
/* 
 * < 리터럴 >
 * 
 * 임의로 지정한 문자열('')을 SELECT절에 기술하게 되면
 * ResultSet을 반환받을 때 데이터를 붙여서 조회할 수 있음
 * 
 */

-- EMPLOYEE테이블로부터 사원명, 급여
SELECT
       EMP_NAME
     , SALARY
     , '원' 단위
  FROM
       EMPLOYEE;
-- 단위같은거 쓰고싶을수도 있고, 조회할 때 컬럼에 뭘 붙이고 싶다~

--------------------------------------------------

/*
 * < DISTINCT >
 * 
 * 조회하고자하는 컬럼 앞에 작성하여 중복된값을 딱 한번만 조회하는 용도
 * 
 * 주의) SELECT에 DISTINCT구문은 한 개만 사용이 가능
 * 
 */

-- 같은 부서인 사람들은 부서 코드가 중복되어서 나오게 됨
-- 중복 제거해서 하나만 확인했으면 좋겠어 하면 컬럼 앞에다가 DISTINCT 키워드를 달아줌
SELECT
       DISTINCT DEPT_CODE
  FROM
       EMPLOYEE;

--------------------------------------------------

/*
 * 여태 EMPLOYEE를 23행 전부를 조회했음, 보통은 이렇게 하지는 않음
 * SELECT문을 이용해서 조회를 할 때 조건을 부여하는 방법!
 * 
 * < WHERE 절 >
 * (SELECT 절 쓸때 얘가 따라붙음, 실과 바늘같은 친구들)
 * 조회하고자 하는 테이블에 특정 조건을 제시해서
 * 조건에 만족하는 행만 조회하고자 할 때 기술하는 구문
 * 
 * [ 표현법 ]
 * SELECT
 *        컬럼명
 *      , 컬럼명
 *      , 컬럼명
 *   FROM
 *        테이블명
 *  WHERE
 *        조건식; 또 시작이네 또 조건식이야, 우리가 알고있는 그 조건식, 맨날 쓰는 그거
 * 
 * - 조건식에 다양한 연산자들을 사용할 수 있음
 * 
 * < 비교연산자 >
 * >, <, <=, >= // 대소비교
 * 
 * =, != // 동등비교(자바에서의 대입연산자가 SQL에서의 동등비교연산자임)
 * 
 */

-- EMPLOYEE테이블로부터 사원들의 사원명, 급여 조회 --> 급여가 300만원 이상인 사원들만(조건! 자바에서 if같은거)
SELECT
       EMP_NAME -- 사원명을 저장해놓은 컬럼
     , SALARY -- 급여를 저장해놓은 컬럼
  FROM
       EMPLOYEE
 WHERE -- 조회를 하는데 조건이 달렸으니까 이 구문 추가
       -- 급여가 300만원 이상인 -- 이게 지금 조건, 급여는 어느 컬럼에? SALARY, 비교는 300만원이니까 3000000, 이상인 조건이므로 비교연산 >=
       SALARY >= 3000000;

-- SELECT를 통해 조회된 행들의 집합을 RESULTSET이라고 함! 항상 행단위임!
-- 보통 다 조회하지 않음, EMPLOYEE에 행이 몇개 있을 줄 알고..
-- DBA라는 직종이 있음, 쌩DB전문가들, 돈도잘번다네요^^ㅎ 신입은 잘 안뽑고...
-- 언제 결과가 나올지 모르니 집에도 못감ㅎ 할일이 많음.. 돈 많이 받을만 하다네요
-- 아무튼 데이터가 많으면 조회하는데 시간이 당연히 오래걸리겄지. 조건없이 SELECT를 한다? 이런건 거의 만들어질리가 없음...
-- 거의 항상 바늘(SELECT) 실(WHERE)

-- EMPLOYEE테이블로부터 부서코드가 D9인 사원들의 사원명, 부서코드 조회
SELECT
       EMP_NAME
     , DEPT_CODE
  FROM
       EMPLOYEE -- SQL할때도 마찬가지, 여기까지 해보고 잘 나오면 그다음에 조건 붙이기!
 WHERE -- 부서코드가 D9인 사원들 : 조건
       DEPT_CODE = 'D9'; -- 비교대상은 대소문자를 구분함, D9라고 똑같이 써야함
       -- 첫번째로 동등비교를 하고싶음, 동등비교는 오라클에서 =를 씀(자바에서는 ==이거였지, 여기서는 하나써야 같니? 라는 의미)
       -- 두번째로 문자형 리터럴이다 라고 표현해줘야함, 여기서는 홑따옴표(자바에서는 쌍따옴표로 했던거!)

-- EMPLOYEE 테이블로부터 부서코드가 D9가 아닌 사원들의 사원명, 전화번호 조회
SELECT
       EMP_NAME
     , PHONE
  FROM
       EMPLOYEE
 WHERE
       DEPT_CODE != 'D9'; -- 얘가 가장 일반적인 방식
-- 오라클에 불일치 연산자가 꽤 많음
-- DEPT_CODE ^= 'D9'
-- DEPT_CODE <> 'D9'

-- 중요한 게 있음! 어려운게 아니지만 항상 SELECT문을 쓸 때 실행 순서를 생각해야함
-- 실행순서 1. FROM -> 2. WHERE -> 3. SELECT(합리적인 실행 순서)
-- DBMS, 오라클은 애초에 이걸 위해 만들어진 친구, 조회 정렬 검색 이런것들을 하기 위해 태어난 친구
-- 각각의 구문을 실행할때도 합리적으로 동작함
-- SELECT FROM WHERE중에서 누가 1등일까? 누가 먼저 실행되는게 합리적일까? 일단 TABLE에 가야 COLUMN이 있는지 없는지 알지
-- EMPLOYEE 테이블에 도달해야 알 수 있음
-- 10만개가 있다면 SELECT먼저 수행하면 이거 손해.. 먼저 걸러야함! 각각의 컬럼 비교해서 걸러냄
-- 실제 SELECT 할 때 필요한 것들만 남겠지! WHERE절 들렀다가 마지막에 SELECT
-- 내가 생각한대로 안나온다? 이러면 실행순서 생각 안해서 그렇다. 오로지 실행순서 생각

--------------------------------------------------

/*
 * < 실습 >
 */

-- 1. EMPLOYEE 테이블에서 급여가 250만원 이상인 사원들의 이름, 급여, 입사일 조회
SELECT
       EMP_NAME
     , SALARY
     , HIRE_DATE
  FROM
       EMPLOYEE
 WHERE
       SALARY >= 2500000;

-- 2. EMPLOYEE테이블에서 부서코드가 D6인 사원들의 이름, 급여, 보너스 조회
SELECT
       EMP_NAME
     , SALARY
     , BONUS
  FROM
       EMPLOYEE
 WHERE
       DEPT_CODE = 'D6';

-- 3. EMPLOYEE테이블에서 현재 재직중인 사원(ENT_YN == 'N')들의 이름, 입사일 조회
SELECT
       EMP_NAME
     , HIRE_DATE
  FROM
       EMPLOYEE
 WHERE
       ENT_YN = 'N';

-- 4. EMPLOYEE테이블에서 연봉이 5000 이상인 사원들의 이름 연봉 조회
-- 단, 연봉컬럼은 별칭으로 연봉으로 조회되게 할 것
SELECT
       EMP_NAME
     , (SALARY * 12) AS "연봉" -- 명확하고 보기 편하라고 ""에 키워드(AS)도 다 써줌, 연산식 소괄호로 묶어줌(SALARY * 12 연봉 이라고 작성해도 동작은 똑같지만 이게 더 한눈에 알아보기 좋다)
  FROM
       EMPLOYEE
 WHERE
       (SALARY * 12) >= 50000000; -- 연산식의 결과도 조건식의 비교대상이 될 수 있다

-- 실제로 우리가 테이블을 구현해서 쓸 일은 없겠죠? 그쪽 DB담당자가 기획자랑 잘 얘기해서 작업하겠지..
-- 우리는 오늘처럼 계정을 받아서 쓰겠지! 실제로는 개발서버 DB랑 테스트서버, 운영서버 다 따로 DB가 있음
-- 아주 작은 규모(나포함 5명개발자..)라면 직접 할 수도 있겠지만 웬만해선 그럴일이 없음
-- 프로젝트때는 우리가 직접 구현해야겠지! 기획도 하고 설계도 해서 만들어서 사용해야함
-- 학원에 있을때는 이런것들을 알고 다룰 수 있어야함. 쉽게 하는 방법을 알려주실 예정(딸깍법)
-- 테이블 만드는게 어렵다기보다는 설계하는게 더 어렵지

--------------------------------------------------

-- 이거 말고 중요한 연산 있었잖여~ 논리연산
/*
 * < 논리 연산자 >
 * 여러 개의 조건을 엮을 때 사용
 * 
 * 오라클에서는 그냥 그대로 AND, OR 이라고 쓰면 됨
 * AND(이면서~~, 그리고) / OR(~~거나, 또는)
 * 
 */

-- EMPLOYEE테이블에서 부서코드가 'D9'면서 급여가 500만원 이하인 사원들의
-- 사원명, 부서코드, 급여 조회
SELECT
       EMP_NAME
     , DEPT_CODE
     , SALARY
  FROM
       EMPLOYEE
 WHERE -- 이번에는 조건이 두개!
       DEPT_CODE = 'D9' -- 첫번째 조건 부서코드가 'D9'와 동등해야 한다(동등한 사원들!)
   AND -- 둘 다 만족시키고 싶으니까 가운데에 AND를 넣어줌
       SALARY <= 5000000; -- 하나가 더 있어, SALARY가 500만보다 작아야함

-- OR도 맛봐야지
-- EMPLOYEE테이블로부터 부서코드가 'D6'이거나 급여가 300만원 이상인 사원들의
-- 이름, 부서코드, 급여 조회
SELECT -- 조회는 확정
       EMP_NAME -- 컬럼명도 확정
     , DEPT_CODE
     , SALARY
  FROM
       EMPLOYEE -- 여기까지 하면 1절
 WHERE
       DEPT_CODE = 'D6'
    OR -- 조건 두개중에 하나만 만족해도 조회를 하고싶음!
       SALARY >= 3000000;

-- EMPLOYEE테이블로부터 급여컬럼의 값이 350만원 이상이고 500만원 이하인 사원들의
-- 사번(EMP_ID), 이름, 급여를 조회
SELECT
       EMP_ID
     , EMP_NAME
     , SALARY
  FROM
       EMPLOYEE
 WHERE
       SALARY >= 3500000
   AND
       SALARY <= 5000000;
-- 엑셀 잘하면 이거 잘할수있음, 개발자보다 이게 나을수도? ㅎ 취향에 맞는 사람이 있을 수 있지
-- 약간 노잼일 수 있다~ 정해진 문법 배우는거라서.. 속도 빠르게 하시겠다네요. 까딱하면 우리가 잠들 수 있음^^!
-- 학교에서도 오라클을 많이 가르치는데 반년정도? 학교에서는 보통 CMD 켜서해서 오래걸릴지도 모른다, 굳이 비버같은 도구 안쓰고 시커먼거로 하겠다고...
-- 우리는 알차고 이쁜 도구 쓰고 있으니까 빠르게 나가봅시다!
-- SQL이 중요하긴 한데 쓰면서 익히면 되는거고...

-- 이번에 조건을 만드는데, 조건이 컬럼의 값이 어느어느 사이의 범위에 포함이 되느냐? 이런거였음
-- 이럴때는 보통 AND연산을 잘 안쓰고 사용하는 친구가 따로 있음

--------------------------------------------------

/*
 * < BETWEEN AND >
 * 몇 이상 몇 이하인 범위에 대해서 조건을 제시할 때 사용
 * 
 * [ 표현법 ]
 * 비교대상컬럼명 BETWEEN 하한값 AND 상한값
 * 
 */

-- 똑같이 해볼것임
-- EMPLOYEE테이블에서 급여가 350이상 500이하인 사원들의 사번 이름 직급코드(JOB_CODE)
SELECT
       EMP_ID
     , EMP_NAME
     , JOB_CODE
  FROM
       EMPLOYEE
 WHERE
       SALARY BETWEEN 3500000 AND 5000000; -- 사이에 포함되어있는지 조건을 주고싶을때 BETWEEN AND를 선호함
       -- AND 연산을 해도 돌아가긴하지만 BETWEEN 쪽을 선호함

-- 이 범위에 포함되지 않는 사원들만 또 보고싶어!
-- EMPLOYEE테이블에서 급여가 350미만이거나 500을 초과하는 사원들의 사번, 이름, 직급코드
SELECT
       EMP_ID
     , EMP_NAME
     , JOB_CODE
  FROM
       EMPLOYEE
 WHERE
       SALARY NOT BETWEEN 3500000 AND 5000000; -- 아닌 친구들을 보고싶은거니까 부정을 해줘야함! 자바에서 느낌표 붙이는 것 처럼 조건을 부정해줘야함
       -- 어떻게 함? NOT을 써줌!
--> 오라클에서의 NOT은 자바의 !와 동일한 의미
-- 날짜 체크할 때 많이 씁니다.
-- 여행가고 이런거 할때 비행기 호텔 예약해야함
-- 트립닷컴에서 예약을 하고싶다고 가정
-- 날짜를 정할텐데, 9월 9일부터 9월 11일까지 정해봄, 여행지는 오사카로 가봅시다
-- 오사카에 간다고 하고 검색을 누르면 이거저거 나오겠지? 이게 지금 조회한거! 이 날짜에 예약할 수 있는 숙소의 정보를 조회한것
-- 그럼 숙소에 대한 정보가 테이블에 이것저것 저장되어 있을거고, 우리가 이렇게 조건을 달아서 요청을 보내면 실질적으로 뒤에서 일어나는 일은?
/*
 *  FROM
 *       TB_HOTEL
 * WHERE
 *       LOCATION = '오사카'
 *   AND
 *       DATE BETWEEN '09/09' AND '09/11'
 * 
 * 이런식으로 조건에 맞는것만 조회해서 들고와서 땡겨오는데 화면에 출력만 해주는거겠지!
 * SELECT문을 하면서 어떤걸 할 수 있을지 생각하면 노잼인데 좀 더 흥미로울 수 있음(?)
 * 
 */

-- BETWEEN AND 연산자는 DATE형식에도 사용 가능
-- 입사일이 '90/01/01' ~ '03/01/01'인 사원들의 이름 입사일 조회
SELECT
       EMP_NAME
     , HIRE_DATE
  FROM
       EMPLOYEE
 WHERE
       HIRE_DATE BETWEEN '90/01/01' AND '03/01/01';
-- 15:27 날짜도 날짜 범위 안에 포함되는 것으로 조건 작성 가능

--------------------------------------------------

-- 지금 오사카 찾았음, 오사카가 조건으로 들어갔겠지?
-- 이게 소테츠 그랜드 프레사 오사카 난바 이렇게 쓴 게 아니고 내가 쓴 키워드가 저기에 포함된걸 찾아버린것
-- 자바 스트림 CONTAINS 이거 어떻게 SQL에서 쓰는지 얘기해보자
/*
 * < LIKE '특정패턴' >
 * 패턴을 만들어서 넣어준다
 * 비교하려는 컬럼의 값이 내가 지정한 특정 패턴에 만족할 경우 조회(LIKE 절)
 * 
 * [ 표현법 ]
 * 비교대상컬럼 LIKE '특정패턴'
 * 
 * - 특정패턴 --> 와일드카드
 * 정규표현식 나중에 배울거니까 지금은 와일드카드라는걸 써보자
 * 와일드카드가 뭐임? 올림픽 축구라고 가정하면 U-23에서 23세 이하인 친구들이 나가서 축구를 하겠지
 * 팀 구성할때 와일드카드를 3장인가 준대. 아무데나 집어넣을 수 있는 땜빵카드같은 느낌?
 * 와일드카드들어가는 친구는 23세아니어도 되고 포지션도 상관없고.. 이런느낌?
 * 오라클에서는 두개를 써보자(퍼센트 사인이랑 언더스코어)
 * '%', '_' 두 가지를 가지고 패턴을 만들 수 있음
 * 
 * '%' : 0글자 이상
 * 		비교대상컬럼 LIKE 'A%' => 컬럼값 중 'A'로 시작하는 것만 조회 -> Apple, Add, A
 * A로 시작하는 것들 찾는 패턴이 됨
 * 
 * 		비교대상컬럼 LIKE '%A' => 컬럼값 중 'A'로 끝나는것만 조회 -> BananA, GolilA, A
 * A로 끝나는 것을 찾는 패턴이 됨(대소문자 구분)
 * 
 * 		비교대상컬럼 LIKE '%A%' => 컬럼값 중 'A'가 포함되는것을 전부 조회
 * 완전 CONTAINS같은 느낌! 포함되어있으면 전부다
 * 
 * '_' : 1글자(언더스코어 하나당 한글자를 의미함)
 * 		비교대상컬럼 LIKE '_A' => 컬럼값에 'A'앞에 무조건 1글자가 있어야만 패턴에 만족
 * 		비교대상컬럼 LIKE '__A' => 컬럼값에 'A'앞에 무조건 2글자가 있어야만 패턴에 만족
 * 
 * 말로 풀어놓으니까 어려워보이지만 해보면 쉬움
 * 
 */

-- EMPLOYEE테이블로부터 모든 사원의 이름, 전화번호 조회
SELECT
       EMP_NAME
     , PHONE
  FROM
       EMPLOYEE;

-- EMPLOYEE테이블에서 성이 '박'씨인 사원들의 사원명, 전화번호(컬럼 이걸로 고정하고 쭉 가봅시다)
-- 23행중에서 박씨인 사원들만 조회하고 싶음, 박씨가 조건이므로 WHERE이 확정
SELECT
       EMP_NAME
     , PHONE
  FROM
       EMPLOYEE
 WHERE
       EMP_NAME LIKE '박%'; -- 성이 박씨인건 어떻게 알아? 이럴 때 쓰는게 LIKE 연산, 비교대상은 EMP_NAME 컬럼값, 시작이 박으로 시작하고 뒤에는 뭐가와도 상관없음 이라는 의미

-- 우리반에 준 이 포함되어있는 사람이 많네요~
-- EMPLOYEE테이블에서 이름에 '준' 이라는 글자가 포함된 사원들의 사원명, 폰번호
-- 두번째든세번째든제일앞이든 상관없이
SELECT
       EMP_NAME
     , PHONE
  FROM
       EMPLOYEE
 WHERE -- 조건이 달렸으니까 이건 무조건이지
       EMP_NAME LIKE '%준%'; -- 이름을 보고 싶은거니까 EMP_NAME
-- '준'이 포함된 패턴만 분석해서 찾아올 수 있음

-- 이름의 두 번째 글자가 '승'인 사원들의 사원명, 핸드폰번호
SELECT
       EMP_NAME
     , PHONE
  FROM
       EMPLOYEE -- 여기까진 100% 확정, 모든 사원이 다 나온다
 WHERE -- 가운데만 승인 사람, 앞에도 한글자 있어야하고 뒤에도 한글자 있어야함
       -- EMP_NAME LIKE '_승_';
	   -- 저게 아닌 사원들만 뽑고 싶을 수도 있잖아요? 그러면 NOT만 붙이면 됩니다
       EMP_NAME NOT LIKE '_승_';

-- 자바였다면? for문 돌려서 string이면 char형 array로 바꿔서 인덱스로 접근하고 equals..
-- for charArr [1].equals("승")
-- 어떤 방법이 합리적인가요? ㅎㅎ SQL이 합리적임
-- 자바라면? 있는거 다 들고간다음에 돌려보겠다는 의미이므로 조회된게 10만개 100만개라면 그만큼 반복해서 돌림
-- SQL은 애초부터 이걸 위해서 만들어진 친구라서.. 웹개발은 사실상의 연산이 다 여기서 이루어져야함
-- 우리는 사실 인간 SQL 작성기가 되어야함ㅎㅎ
-- 이걸 자바로 들고가는순간 속도낭비 연산낭비 스트링이니까 메모리 공간 낭비
-- 문자열 들고가서 자바에서 뭘 하겠다고 생각하는 순간 낭비! 여기서 처리할 수 있는건 여기서 다 끝내고 가야함, 그래야 효율적임
-- 코드로 해두면 이걸 바꿔야 할 경우에 코드를 수정해야함
-- SQL은 이걸 하기 위한 문법이기 때문에 SELECT를 잘 알아두는것이 좋다 매우 중요한 친구~

--------------------------------------------------

/*
 * < LIKE 실습문제 >
 * 
 */

-- 1. EMPLOYEE테이블로부터 전화번호 4번째 자리가 9로 시작하는 사원들의 사원명, 전화번호
SELECT
       EMP_NAME
     , PHONE
  FROM
       EMPLOYEE
 WHERE
       PHONE LIKE '___9%'; -- % 없으면 네자리만 찾아오므로 뒤에 아무거나 붙어도 상관없다는 의미로 % 붙여줌

-- 2. EMPLOYEE테이블로부터 이름이 '영'으로 끝나는 사원들의 이름, 입사일
SELECT
       EMP_NAME
     , HIRE_DATE
  FROM
       EMPLOYEE
 WHERE
       EMP_NAME LIKE '%영'

-- 3. EMPLOYEE테이블로부터 전화번호 처음 3자리가 010이 아닌 사원들의 이름, 전화번호
SELECT
      EMP_NAME
    , PHONE
 FROM
      EMPLOYEE
WHERE
      PHONE NOT LIKE '010%';
-- 오라클 학습할 때 이렇게 하라고 제공되어 있는 공식따라 하고계심 물론 영어는 이름 바꾸고 컬럼추가하고 했지만 오라클에서 학습하라고 제공해둔 방식대로 하고계십니다~

-- 4. DEPARTMENT 테이블로부터 해외영업과 관련된 부서들의 부서명 조회
-- 뭔지 모르겠을때는 일단 다 조회해봄(ㅎ 지금은 몇개 없으니까 가능한거아닐까?)
SELECT
	   *
  FROM
       DEPARTMENT;

-- 이제 *을 고쳐서 작성
SELECT
       DEPT_TITLE
  FROM
       DEPARTMENT
 WHERE
       DEPT_TITLE LIKE '%해외영업%';

--------------------------------------------------

/*
 * < IS NULL >
 * NULL이랑 비교연산(NULL 이냐 아니냐를 연산함)
 * 
 * [ 표현법 ]
 * 비교대상컬럼 IS NULL : 컬럼값이 NULL일경우
 * 비교대상컬럼 IS NOT NULL : 컬럼값이 NULL이 아닐 경우
 * 
 */

-- 사원명과 보너스를 조회
-- 누구는 보너스가 있고 누구는 없는 악덕회사^^
SELECT
       EMP_NAME
     , BONUS
  FROM
       EMPLOYEE;
-- EMPLOYEE테이블로부터 보너스를 받지 않는(보너스가 없는) 사원들의 사원명, 보너스 조회
SELECT
       EMP_NAME
     , BONUS
  FROM
       EMPLOYEE
 WHERE
       -- BONUS = NULL; 이렇게 하면 NULL인지 인식을 못함, 동등비교 연산자가 아니고 IS NULL을 써야함
       -- BONUS IS NULL; 이거 은근 쏠쏠한데 잘 까먹음, 왜 널값이랑 비교가 안되지? 하면 IS NULL을 안썼기 때문
       -- 반대로 보너스를 받는 사원을 보고싶다면 IS NOT NULL로 NOT만 붙이면 됨
       BONUS IS NOT NULL;

--------------------------------------------------

/*
 * < 연결연산자 || > (자바의 OR연산자같이 파이프라인을 두개씀)
 * 여러개의 컬럼 값들을 마치 하나의 컬럼인것처럼 연결시켜주는 연산자
 * 컬럼값 또는 리터럴(문자열)을 전부 다 합칠 수 있음
 * 
 * 자바에서 문자열 합칠때 더하기 연산 했던거
 * System.out.println(num + "sdfsd");
 * 
 */
SELECT
       EMP_ID || EMP_NAME
  FROM
       EMPLOYEE; -- 조회한것을 하나의 결과로 합쳐서, 하나의 컬럼에 결과를 보여줄 수 있음

-- 컬럼, 리터럴 합칠 수 있고, 한 번, 여러번 합칠 수 있음
-- 16:19 컬럼값이랑 리터럴 다 합쳐서 반환받을 수 있음
SELECT EMP_ID || '번 사원 ' || EMP_NAME || '님의 핸드폰 번호는 ' || 
	   PHONE || '입니다.' AS "사원의 정보"
  FROM
       EMPLOYEE;
-- 16:19 자바에서는 문자열로 연산하면 메모리 낭비이지만 여기서 하면 효율적?

--------------------------------------------------

/*
 * < IN >
 * 비교대상 컬럼값에 내가 제시한 목록들 중에 일치하는 값이 있는지
 * 
 */
-- EMPLOYEE테이블로부터 부서코드가 D6이거나 D8이거나 D5인 사원들의 사원명, 부서코드 조회
-- 충분히 있을법한 상황이지! 세개부서중에 아무거나 포함되는거 조회하겠다!
-- 거나, 거나 니까 OR 쓰면 되겠지
SELECT
       EMP_NAME
     , DEPT_CODE
  FROM
       EMPLOYEE
 WHERE
       DEPT_CODE IN ('D6', 'D8', 'D5');
 /*
       DEPT_CODE = 'D6'
    OR
       DEPT_CODE = 'D8'
    OR
       DEPT_CODE = 'D5';
*/
-- 이렇게 쓰기 너무 힘드네요, 일단 조회 결과가 12행인데, 이걸 IN을 쓰면 훨씬 간결하게 쓸 수 있음

--------------------------------------------------

/*
 * < 연산자 우선순위 >
 * 
 * 수학익힘책 잘못알면 연산 이상하게 됩니다
 * 1. ( )
 * 얘가 무조건 일등, 우선순위가 높음
 * 
 * 2. 산술연산자
 * 더하기 빼기 곱하기 나누기
 * 
 * 3. 연결연산자
 * 산술연산자 끝나면 합치기
 * 
 * 4. 비교연산자
 * 연결하고 난 다음에는 비교를 함(대소비교, 동등비교)
 * 
 * 5. IS NULL, LIKE, IN
 * 얘네는 우선순위가 똑같음, 앞에있는애(왼쪽)부터 처리함, 수학익힘책 방식
 * 
 * 6. BETWEEN AND
 * 여기까지 끝나면 NOT이 수행됨
 * 
 * 7. NOT
 * NOT 끝나면 AND
 * 
 * 8. AND
 * AND 끝나야 OR
 * 
 * 9. OR
 * 오라클은 AND OR 순서가 다름!! OR가 앞에 있어도 AND를 먼저 연산함! 앞에 수행하고 싶은게 있으면 괄호쳐서 처리해야함
 * 
 */

--------------------------------------------------

/*
 * < ☆★☆★☆★☆★☆★☆★☆★ ORDER BY 절 ☆★☆★☆★☆★☆★☆★☆★ >
 * 기본문법이라 많이 쓰다보면 익혀지는데 이친구는 굉장히 굉장히 많이 중요함
 * 
 * 정렬용도로 사용하는 구문
 * SELECT문에 가장 마지막에 작성하는 문법 + 실행 순서 또한 가장 마지막
 * ORDER BY절을 작성하지않으면 ResultSet은 정렬이 안된 상태
 * 
 * [ 표현법 ]
 * SELECT
 *        컬럼명
 *      , 컬럼명
 *      , ...
 *   FROM
 *        테이블명 <- 여기까진 필수임! SELECT ~ FROM ~
 *  WHERE
 *        조건식(생략가능) <- 없다고 해서 SELECT문이 안돌아가지는 않음
 *  ORDER
 *     BY
 *        [ 정렬기준으로 삼고싶은 컬럼명 / 별칭 / 컬럼 순번 ]
 *        [ASC / DESC] <- 오름차순 / 내림차순
 *        [NULLS FIRST / NULLS LAST] (생략가능) <- 컬럼에 NULL값이 포함되어 있는 경우가 있을 수 있음, 이걸 앞으로 할 지 뒤로 할 지
 * 
 * - ASC : 오름차순 정렬(기본값)
 * - DESC : 내림차순 정렬
 * 
 * - NULLS FIRST : (S조심, NULL FIRST 아님!) 컬럼값이 NULL일 경우 조회결과의 위쪽에 배치(내림차순일 경우 기본값)
 * - NULLS LAST : 컬럼값이 NULL일 경우 조회결과의 아래쪽에 배치(오름차순일 경우 기본값)
 * 
 */

SELECT
       EMP_ID
     , EMP_NAME
  FROM
       EMPLOYEE;
-- 이렇게 조회하는데, 조회하는것까진 오케이... 조회된 행들의 집합은 ResultSet
-- 보여지는게 어떻게 보여짐? 얼핏 보면 EMP_ID 항목을 봤을 때 숫자가 오름차순으로 정렬이 된 것처럼 보임(숫자가 1씩 올라가면서)
-- 마치 정렬이 된 것 처럼 보이는데, 지금 정렬이 안되어있는 상태임! 운이 좋아서 정렬된것처럼 보임
-- 정확히는 선생님이 인덱스를 만들어뒀는데, 정렬기준을 안달아놔서 인덱스 따라 나온것이고, 운이 좋아서 정렬된것처럼 보임
-- SELECT 구문은 기본적으로 정렬해야함! 오라클 공식 문서에 써있음! 정렬이 안되어있는것이고 우리가 운이 좋은것
-- 16:32 ResultSet을 뽑을 때 ORDER BY절을 써야함!!
-- 언제든지 순서가 뒤죽박죽 될 수 있음

-- BONUS 컬럼 같이 조회할건데, 미정렬 상태니까 정렬 한번 해보자
SELECT
       EMP_ID
     , EMP_NAME
     , BONUS
  FROM
       EMPLOYEE
 ORDER
    BY
       -- BONUS; 옵션 따로 안주고 이렇게 실행시키면 0.1부터 점점 커지고 마지막에 NULL나옴, 이게 기본값, ASC / DESC 생략 시 ASC(오름차순)
       -- BONUS DESC; 내림차순으로 조회 정렬, 앞에 NULL값들이 나오고, 그다음 BONUS 컬럼이 큰거부터 작은거 순서대로 나옴, 내림차순 정렬 시 기본적으로 NULLS FIRST
       -- BONUS DESC NULLS LAST; 이러면 NULL은 밑으로 내리고, 보너스는 내림차순으로 나옴
       BONUS, EMP_ID, EMP_NAME; -- 보너스가 똑같이 나올 수 있음, 이런 경우의 정렬 기준을 추가로 지정, 첫번째것으로 정렬, 똑같다면 그다음 정렬 기준으로 정렬, 줄줄이 여러개 작성할 수 있음
-- 첫 번째로 제시한 정렬기준의 컬럼값이 동일할 경우 다음 정렬기준을 명시할 수 있음
-- ORDER BY를 써야 정렬된다!

-- 컬럼에 이것저것 여러개 섞여있을 수 있음, 컬럼도 자료형이 정해져 있음
-- 동일한 컬럼에 어디에는 숫자, 어디에는 문자 이렇게 들어갈수는 없음
-- 만약에 글로벌한 DB야, 일본어, 한국어, 중국어, 영어 이렇게 섞여있을 수 있음
-- 이런게 오름차순 정렬하면? 무조건 영어가 제일 앞, 그다음에 동아시아 3국을 놓고 보면 중국 일본 한국 순
-- 국가번호가 있어서(식별하는 번호) 이거 기준으로 나옴, 여러개의 언어가 섞여있으면 한글이 늦게나오는데 내림차순 하면 먼저 나오겠지

-- 이런 경우도 있을 수 있음, 예를 들어서 연봉을 생각해봤을때, 별칭을 지어줬음
-- 예를 들어서 이게 WHERE절이라면? 내가 붙인 별칭으로 조건믄 작성이 안됨
SELECT
       EMP_NAME
     , SALARY * 12 AS "연봉"
  FROM
       EMPLOYEE
 WHERE
       -- 연봉 > 40000000; 이런건 안됨, 왜안됨?
       SALARY * 12 > 40000000
       -- 정렬기준으로는 쓸 수 있는데 조건절에서는 못씀
       -- 이유는 실행순서!
       -- 제일 먼저 수행되는 애는? 테이블에 찾아가야함! 가야 컬럼이 있는지 없는지 알 수 있음
       -- 1. FROM
       -- 2. WHERE 조건절, 그래야 맞는거만 추려서 컬럼 가져올것임
       -- 3. SELCET, 여기 와서야 별칭이 지어짐, 그러므로 2번에서 별칭을 쓸 수 없음
       -- 4. ORDER BY, 얘는 마지막이니까 SELECT에서 별칭 지어준것을 쓸 수 있음
       -- 500만개 먼저 정렬하고 추리느냐? 필요한것만 가져와서 정렬을 하냐? 효율의 차이
 ORDER
    BY
       -- 연봉; 별칭 사용가능
       2; -- 2번 컬럼을 기준으로 정렬하겠다고 한 것이지만 최악의 방법, 되긴 되지만, 최악...까진 그렇고 권장하지 않는 방법(비추천), 컬럼은 바뀌거나 순서가 바뀌거나 추가되거나 사라질 수 있음, 그때마다 수정되어야함

-- 드디어 첫번째 파일 SELECT문 기본문법 끝!
-- 12개에서 14개 정도 만들예정, 이러면 SQL문 오라클 끝! 이번주에 끝내야함, 다음주에 할 게 중요함
-- 보고 쳐도 되긴 함... 빠듯하면 12개 널널하면 14개?
-- 이친구도 GIT HUB에 올려서 관리할 수 있음! 시원하게 올려주자
