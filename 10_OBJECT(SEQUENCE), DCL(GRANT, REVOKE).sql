/*
 * 1. 오라클에서 난수 만드는 함수 2. 시퀀스
 * 수치가 작아서 시퀀스를 써보기로
 * 
 * < 시퀀스 SEQUENCE >
 * 자동으로 번호를 발생시켜주는 역할을 하는 객체
 * 정수값을 자동으로 순차증가시켜 생성해줌
 * 
 * -- 회원번호, 사원번호, 게시글번호, 예약번호, 주문번호 등등 채번 할 때 주로 사용함
 * 
 * 아주 옛날말 채번
 * 영어로 시퀀스. 순차적으로 나열된걸 시퀀스로 하니까..
 * 오라클에서 시퀀스를 객체로 제공하고 있음, 만들어서 쓰면 됨
 * 
 * 1. 시퀀스 객체 생성 구문
 * 
 * [ 표현법 ]
 * CREATE SEQUENCE 시퀀스명
 *  START WITH 시작숫자 -> (채번할때 일반적으로 1부터 시작하는데 내가 시작숫자 지정할 수 있음, 1000번부터, 10000번부터 이런식으로) 시작값을 지정하는 옵션
 *  INCREMENT BY 증가값 -> (한번 증가할때 얼마씩 증가시킬것인가) 값을 증가시킬 때 몇 씩 증가할건지 지정하는 옵션
 *  MAXVALUE 최대값 -> (시퀀스로 만들어낼 수 있는) 최대값 지정 옵션
 *  MINVALUE 최소값 -> 최소값 지정 옵션
 *  CYCLE / NOCYCLE -> (최대값에 도달했을 때 다시 처음으로 돌아갈것인지) 순환 여부 지정
 *  ---------- 생략가능
 *  CACHE 바이트크기 / NOCACHE -> 캐시메모리 쓸건지 말건지(보통 위에거는 다 생략하는 경우가 많고, 이 옵션은 씀, 생략이 가능하지만 일반적으로는 노캐시, 성능이 필요하면 캐시 지정해서 쓰기도 함)
 * 							-> CACHE_SIZE 기본값은 20 BYTE
 * 
 * * CACHE : 미리 발생할 값을 생성해서 저장을 해둘건지 말건지 여부 지정
 * 			 값이 필요할 때마다 매 번 새롭게 값을 생성해내는것 보다는
 * 			 캐시공간에 미리 생성된 값들을 가져다 쓰는것이 훨씬(속도가 빠르겠지, 바로 가져오기만 하면 되니까) 속도적인 측면에서 이득이있음
 * 			 (캐시공간은 소중한 공간이라서.. 일반적으로 연산장치를 CPU로 표현하는데, 여기도 값을 올릴 수 있는 공간이 있어야 연산하겠지, 얘도 캐시 메모리를 가지고 있는데 고급 공간을 조금 가지고 있음)
 * 			 (고급 공간이라서 생각을 좀 하고 써야함)
 * 			 단, 접속이 끊기고 나서 재접속 후 기존 생성된 값들이 다 날아가고 없음
 * 			 (?? 껐다켜면 어케됨 ?? 번호의 연속성도 고려해야함)
 * 일반적으로 공부하다가 캐시가 나오면 저장하는 메모리인데, 연산장치에 달려있거나 한 램보다 고급메모리(비싸고 작고)
 * 시퀀스로 값을 만들어내는데, 내가 만들어야 하는 값이 뭔지 연산한 다음에 값을 줌, 그러고 또 달라고 하면 연산하고 만들어주고 이런식(시퀀스 내부에서 연산하는 과정이 필요)
 * 달라고 할때마다 계산하면 그때마다 자원이 소모되고 연산이 많아지니까 미리 숫자를 20개를 만들어놓겠다는 뜻, 만들어놓고 고급진 메모리에 저장해놨다가 누가 시퀀스 달라고 하면 만들어놓은것을 주겠다
 * 고급 메모리 공간이라고 생각하면 됨
 * 
 */

/*
 * 오라클에서의 객체는 전부 접두사를 붙여주는 편
 * * 접두사
 * - 테이블명 : TB_
 * - 뷰 : VW_
 * - 시퀀스 : SEQ_
 * - 트리거 : TRG_
 * - 유저는 따로 아무것도 안붙임
 * 
 */
SELECT * FROM EMPLOYEE;
-- 여기서 PK 역할은 사번을 저장하는 EMP_ID 컬럼
-- 이 번호를 사람이 직접 쓴다면? 사실 좀 복잡하지
/*
SELECT MAX(EMP_ID) FROM EMPLOYEE;
-- 제일 큰 아이디를 일단 알아낸다음에
-- 스칼라 쿼리를 써서???
INSERT
       VALUES((SELECT MAX(EMP_ID) + 1 FROM EMPLOYEE), );
-- MAX + 1은 901임.. 우리가 필요한건 224인데.. 사람이 224, 225 쓰긴 그렇지 실수할수도 있고..
-- 이런 상황에서 필요한게 시퀀스!
*/

-- 시퀀스 하나 만들어서 해보자
CREATE SEQUENCE SEQ_EMPNO
 START WITH 224 -- 필요한 값이 224니까 시작값 옵션 주고 캐시 안쓸거니까 NOCACHE 지정하자
 NOCACHE;

-- 만든 시퀀스를 사용해보자
/*
 * 2. 시퀀스를 사용하는 방법(두가지를 알아야함)
 * 시퀀스명.CURRVAL : 현재 시퀀스의 값(마지막으로 성공적으로 만들어진 NEXTVAL 값) -- 시퀀스명에 참조연산자 찍고 현재 시퀀스의 값
 * 시퀀스명.NEXTVAL : 시퀀스값을 증가시킨 뒤 증가된 시퀀스의 값
 * 					기존 시퀀스 값에서 INCREMENT BY값만큼 증가한 값
 * 					(시퀀스명.CURRVAL + INCREMENT BY값(기본값 1))
 * 
 * 시퀀스 생성 시 첫 NEXTVAL은 START WITH로 지정한 시작값으로 발생(우리는 224로 발생한 것)
 * 
 */

SELECT SEQ_EMPNO.CURRVAL FROM DUAL; -- 테이블 없으니까 DUAL로 돌릴건데 어차피 안됨
-- 시퀀스 SEQ_EMPNO.CURRVAL은 이 세션에서는 정의 되어 있지 않습니다
-- 지금 DB 접속했는데,,
-- NEXTVAL를 한 번이라도 수행하지 않으면 CURRVAL을 사용할 수 없음
-- CURRVAL은 마지막에 성공적으로 만들어진 NEXTVAL를 보여주는 임시 값
-- NEXTVAL을 안하면 CURRVAL을 쓸 수 없다, NEXTVAL을 꼭 먼저 해야한다

-- 그래서 NEXTVAL을 써보자
SELECT SEQ_EMPNO.NEXTVAL FROM DUAL; -- 그냥 숫자가 나오는데, 이거 실행할때마다 숫자가 늘어남

-- 이제 CURRVAL 할 수 있음, 마지막으로 만들어진 NEXTVAL값
SELECT SEQ_EMPNO.CURRVAL FROM DUAL;

-- 딕셔너리 한번 보자
SELECT * FROM USER_SEQUENCES; -- LAST_NUMBER 컬럼에 있는 값이 지금 NEXTVAL 하면 무슨 값 나오는지 보여주는 것
-- LAST_NUMBER : 지금 NEXTVAL하면 나오는값

-- 객체니까 수정하고 싶으면 ALTER, 지우고 싶으면 DROP하면 됨
-- 수정 : ALTER --> START WITH는 변경 불가능 너무 바꾸고싶으면 DROP하고 다시 CREATE(딴거 다 바꿀 수 있는데 시작값은 못바꿈)
-- 삭제 : DROP

-- 새로 만들자
CREATE SEQUENCE SEQ_EID
 START WITH 224;

-- 사원을 추가해야할 때마다 수행하는 INSERT
-- 원래는 우리가 정수값 때려박음
INSERT
  INTO
       EMPLOYEE
       (
       EMP_ID
     , EMP_NAME
     , EMP_NO
     , JOB_CODE
     , SAL_LEVEL
       )
VALUES
       (
       SEQ_EID.NEXTVAL
     , '강호동'
     , '222222-1111111'
     , 'J3'
     , 'S2'
       );
-- 정수값 직접 적지 않겠다, 사람이 하면 실수할 수 있으니까

SELECT * FROM EMPLOYEE;

INSERT
  INTO
       EMPLOYEE
       (
       EMP_ID
     , EMP_NAME
     , EMP_NO
     , JOB_CODE
     , SAL_LEVEL
       )
VALUES
       (
       SEQ_EID.NEXTVAL
     , '유재석'
     , '222222-1111111'
     , 'J3'
     , 'S2'
       );

SELECT * FROM EMPLOYEE;
-- 우리가 INSERT 할 때마다 1씩 증가해서 알아서 들어감

--------------------------------------------------

/*
 * < DCL : DATA CONTROL LANGUAGE >
 * 데이터 제어 언어
 * 
 * 데이터베이스 위험하네.. 누구나 SELECT 해서 정보를 다 볼 수 있네..
 * 실제로 회사 가서도 계정 만들고 이러진 않고 필요한 권한만 받고, 그 권한에 맞는것만 사용할 수 있음(애초에 부서도 다름)
 * 
 * 계정에게 시스템 권한 또는 객체 접근 권한을 부여(GRANT)하거나 회수(REVOKE)하는 언어
 * 
 * DB는 항상 계정에 권한이 있어야 뭘 할 수 있음
 * 
 * * 권한 부여(GRANT)
 * - 시스템 권한   : DB에 접근하는 권한, 객체를 생성할 수 있는 권한
 * - 객체 접근 권한 : 특정 객체들에 접근해서 조작할 수 있는 권한
 * 
 * 윤기님이 태호님 테이블에 작업하고 싶은데 계정이 다름, 객체접근권한이 없으면 작업이 안되니까 권한 부여로 해줄 수 있음
 * 
 * -- 객체 접근권한 부여하는 법
 * [ 표현법 ]
 * GRANT 권한종류(SELECT, INSERT, UPDATE, DELETE 등) ON 객체명(아마 주로 테이블명) TO 계정명;
 * 
 * 이건 별로 안중요하고 실질적으로 중요한건 시스템 권한
 * * 시스템권한은 종류(많음)
 * - CREATE SESSION : 계정에 접속할 수 있는 권한
 * - CREATE TABLE : 테이블을 생성할 수 있는 권한
 * - CREATE VIEW : 뷰를 생성할 수 있는 권한
 * - CREATE SEQUENCE : 시퀀스를 생성할 수 있는 권한
 * 
 * GRANT 권한1, 권한2, ... TO 계정명;
 * 시스템 권한은 전부 이렇게 주고싶은 권한 나열하고 누구한테 줄 지 적음
 * 
 * 기본적으로 관리자계정에서 할 수 있음
 * 관리자계정은 새로운 사용자를 만들어낼 수 있음
 * CREATE USER 계정명 IDENTIFIED BY 비밀번호;
 * 계정명 = 사용자명
 * 이걸 가지고 접속해야겠다~ 하고 시도하면 접속이 안됨ㅎ
 * 만들고 권한 부여를 안했음 DB에 접속할 수 있는 권한이 없음(처음 계정을 만들면 권한이 없는 상태)
 * 관리자계정에서 접속할 수 있도록 CREATE SESSION 권한을 부여해줘야 이 계정이 접속할 수 있게됨
 * 모든게 세부적으로 권한이 나뉘어져있어
 * 
 * 반대로 권한을 회수하는것도 있음
 * REVOKE CREATE SESSIOIN FROM 계정명;
 * 줄때는 TO, 뺏을때는 FROM
 * 뺏을 수 있는 권한도 따로있음
 * DB는 권한권한으로
 * 
 * 보통 이렇게 세세하게 주지 않고, ROLE이라고 권한들을 모아놓은 게 있음
 * 
 * < ROLE >
 * 특정 권한들을 하나의 집합으로 모아놓은 것
 * 
 * CONNET, RESOURCE
 * (뭐 포함 안되어있어서 따로 줘야함?)
 * 
 * < 권한 회수 REVOKE >
 * [표현법]
 * REVOKE 권한1, 권한2... FROM 사용자명;
 * 
 */

/*
SELECT
       *
  FROM
       ROLE_SYS_PRIVS; -- 이거 실행하면 볼 수 있음
 WHERE
       ROLE IN()
*/