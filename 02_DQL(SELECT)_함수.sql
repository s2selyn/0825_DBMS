/*
오라클에서 제공하는 함수들에 대해서 알아보자!
	함수 < FUNCTION >

	자바로 따지면 메소드(내장함수, BUILT IN FUNCTION, 얘네는 입력값을 주면 무조건 결과값이 반환됨)
	메소드는 반한되는것이 없을수도 있지만 얘는 함수기때문에 무조건 입력 들어가면 출력이 나옴
	전달된 값을 가지고 계산된 결과를 반환해준당
	
	- 단일행 함수 : N개의 값을 읽어서 N개의 결과를 반환(매 행마다 함수 결과 반환)
	- ★☆그룹 함수★☆ : N개의 값을 읽어서 1개의 결과를 반환(그룹별로 함수 결과 반환)

*/

------------------------- < 단일행 함수 > -------------------------
SELECT
       SALARY -- 23행
     , LENGTH(SALARY) -- 각각의 SALARY 행마다의 실행결과가 반환됨, 총 23행
     , SUM(SALARY) -- 얘는 하나가 반환됨, ResultSet의 결과가 다르므로 같이 쓸 수 없음
  FROM
       EMPLOYEE;
-- 단일행 함수와 그룹함수는 함께 사용할 수 없음 : 결과 행의 개수가 다르기 때문
-- 그룹함수는 그룹 개수만큼 나온다

-- 17:19 외우지 말고, 써보고 넘어갈것임, 이런게 있다는것만 알고?
-- 하다보면 지겨워서 그렇지 어려운것은 없음, 졸릴 수 있으니 빠르게 하고 넘어가자
/*
 * < 문자열과 관련된 함수 >
 * LENGTH / LENGTHB
 * 
 * STR : '문자열' / 문자열이 들어가있는 컬럼
 * 
 * 자바에서 이런거 있었음, length메소드 --> 문자열의 길이가 온다, 이거랑 똑같음
 * "equals".length(); <-- 얘랑 똑같아용
 * - LENGTH(STR) : 전달된 문자열의 글자 수 반환
 * 함수 호출하면서 인자로 문자열을 전달
 * 
 * - LENGTHB(STR) : 전달된 문자열의 바이트 수(크기) 반환
 * 
 * 결과는 NUMBER타입(오라클은 정수, 실수 구분하지 않고 전부 NUMBER 타입으로 취급)
 * 날짜는 DATE, TIMESTAMP
 * 17:22 문자는 CHAR, ??? 이런것들로 나눠져있음
 * 
 * 한글 : 'ㄱ', 'ㅏ', '강' => 한 글자당 3Byte
 * 숫자, 영어, 특수문자 => 한 글자당 1Byte
 * 
 */
SELECT 
       LENGTH('오라클!')
     , LENGTHB('오라클!')
-- 이렇게는 못써! FROM절은 무조건 있어야함!
  FROM
       -- EMPLOYEE; 이 테이블에서 뭔가 하고싶은게 아니고 순수하게 단순히 함수를 호출해서 테스트해보고싶음 --> 가상 테이블 사용
       DUAL; -- 가상테이블(DUMMY TABLE)

-- 실제 테이블의 컬럼 가지고 해보면?
SELECT
       EMAIL
     , LENGTH(EMAIL)
  FROM
       EMPLOYEE;
-- 각각의 길이가 다른 이메일 주소를 함수를 써서 반환받을 수 있다

--------------------------------------------------

/*
 * INSTR(indexOf같은느낌)
 * 
 * - INSTR(STR) : 문자열로부터 특정 문자의 위치값 반환
 * 
 * INSTR(STR, '특정 문자', 찾을위치의 시작값, 순번)
 * 인자로 넘길 수 있는 요소가 굉장히 많음
 * 1. STR
 * 2. 찾고싶은 특정문자
 * 3. 찾을 위치의 시작값
 * 4. 순번
 * 
 * 결과값은 NUMBER타입으로 반환
 * 찾을 위치의 시작값과 순번은 생략이 가능
 * 
 * 찾을 위치의 시작값
 * 1 : 앞에서부터 찾겠다.(기본값)
 * -1 : 뒤에서부터 찾겠다.
 * 
 */

SELECT
       INSTR('AABAACAABBAA', 'B') -- 문자가 엄청 길 경우, 인덱스랑 다름! 1부터임!!
  FROM
       DUAL; -- 원하는 글자가 몇번째에 있는지 찾을 수 있음

-- 인자를 두개가 아니라 세개를 전달할수도 있음
SELECT
       INSTR('AABAACAABBAA', 'B', -1) -- 10이 반환된다. -1을 전달하면 뒤에서부터 첫번째 B가 앞에서부터 몇번째인지 찾겠다는것
  FROM
       DUAL; -- 뒤에서부터 첫 번째 'B'가 앞에서부터 몇 번째인지

SELECT
       INSTR('AABAACAABBAA', 'B', 1, 3)
  FROM
       DUAL; -- 해당 문자열에서 B를 찾을건데, 1이니까 앞에서부터 찾을건데, 앞에서부터 세번째 B가 전체 문자열의 몇번째에 있는지
       -- 앞에서부터 세 번째 'B'가 앞에서부터 몇 번째인지

-- 실제 테이블에 해보자
SELECT
       INSTR(EMAIL, '@') "@의위치" -- 서로 다른 골뱅이의 위치를 INSTR로 알아낼 수 있다
  FROM
       EMPLOYEE; -- 골뱅이의 위치가 다 다름, 아이디 길이에 따라 다름

--------------------------------------------------

/*
 * SUBSTR
 * 17:39 뭐랑 같다고요?
 * 
 * - SUBSTR(STR, POSITION, LENGTH) : 문자열로부터 특정 문자열을 추출해서 반환
 * 
 * - STR : '문자열' 또는 문자타입 컬럼 값
 * - POSITION : 문자열 추출 시작위치값(POSITION번째 문자부터 추룰) -> 음수도 가능
 * - LENGTH : 추룰할 문자 개수(생략 시 끝까지라는 의미)
 * 
 * 문자 빼기 자르기임!
 * 
 */

SELECT
       SUBSTR('KH정보교육원', 3) -- 세번째부터 마지막까지 추출해서 반환, LENGTH를 따로 전달 안했으므로
  FROM
       DUAL;

-- LENGTH를 같이 전달해보자
SELECT
       SUBSTR('KH정보교육원', 3, 2) -- 세번째부터 두개만 추출해서 반환
  FROM
       DUAL;

-- 이 POSITION을 음수값으로 해보자
SELECT
       SUBSTR('KH정보교육원', -3, 2) -- 마이너스는 뒤에서부터! 교 부터 추출하겠다는 의미
  FROM
       DUAL; -- POSITION이 음수일 경우 뒤에서 N번째부터 추룰하겠다 라는 의미

-- 오늘의 마지막 실습
-- EMPLOYEE 테이블로부터 사원명과 이메일컬럼과 EMAIL컬럼값 중 아이디값만 추출해서 조회
SELECT
       EMP_NAME
     , EMAIL
     , SUBSTR(EMAIL, 1, INSTR(EMAIL, '@') -1) "아이디"
  FROM
       EMPLOYEE;
-- 17:48 함수의 반환값이 NUMBER이므로 다른 함수의 인자로 전달해서 사용가능

-- 오라클 내장 함수 얘기 하다가 끝났음~ 한번씩 써보고 넘어가요, 외우지는 마시고...
SELECT
       *
  FROM
       EMPLOYEE;
-- 9:24 보통의 데이터베이스에는 구분을 위해서 식별하기 위한 역할로 숫자를 달아줌
-- 이름을 저장해두는 EMP_NAME, 주민등록번호(실제로는 이러면 안됨, 암호화 해야함) 저장하는 EMP_NO, 등등
-- MANAGER_ID는 자기 사수의 EMP_ID
-- HIRE_DATE 입사일, ENT_DATE 퇴사일, ENT_YN 퇴사여부
-- 이번에는 이 사원을 성별로 구분하고싶음, 근데 EMPLOYEE 테이블에 성별에 대한 항목은 저장이 안되어있음
-- 뭘 봐야 성별을 구분할 수 있음? 주민등록번호를 보면 구분할 수 있음, 주민번호의 7번째 자리
-- 이름과 1, 2만 구분해보자
SELECT
       EMP_NAME
     , EMP_NO -- 여기에서 1인지 2인지 뽑으려면? SUBSTR
     , SUBSTR(EMP_NO, 8, 1) -- 짝대기도 글자수에 포함해야죠 그래서 8번째 글자
  FROM
       EMPLOYEE;
-- 남성 사원들만 이름을 조회 --> 조건이 붙었으니 WHERE
SELECT
       EMP_NAME
  FROM
       EMPLOYEE
 WHERE
       SUBSTR(EMP_NO, 8, 1) = 1; -- 동등비교는 등호, 엄밀히 따지면 반환이 문자열이므로 '1'로 작성해야함

--------------------------------------------------

/*
 * LEFTPADDING / RIGHTPADDING
 * LPAD / RPAD
 * 
 * - LPAD / RPAD(STR, 최종적으로 반환할 문자의 길이(바이트), 패딩할문자)
 * : 인자로 전달한 문자열에 임의의 문자를 왼쪽 또는 오른쪽에 덧붙여서 N길이만큼의 문자열 반환
 * 
 * 결과값은 CHARACTER타입으로 반환(오라클에서 문자를 저장하는 타입, CHARACTER)
 * 덧붙이고자 하는 문자는 생략 가능
 * 
 */

SELECT
       EMAIL -- 이메일은 글자수가 다 다름, 왼쪽에 패딩을 하고싶음, 패딩입으면 빵빵한것처럼 빵빵하게 채우기
  FROM
       EMPLOYEE;

SELECT
       LPAD(EMAIL, 25) -- 아무것도 안넣으면 공백문자로 채워줌
  FROM
       EMPLOYEE;

SELECT
       LPAD(EMAIL, 25, '!') -- 내가 입력한 문자를 빵빵하게 깃털 넣어서 채워줌!
  FROM
       EMPLOYEE;

-- 어떨 때 쓰느냐?
SELECT
       EMP_NAME
     , EMP_NO
  FROM
       EMPLOYEE;
-- 웹사이트에 사람 이름이랑 주민번호가 다 나올수는 없음
-- 이벤트하거나 정보를 띄워줘야하는데, 이걸 이렇게 그대로 보여주면 안되고 이승철 이라면 이**, 111111-1111111 이라면 111111-1****** 이렇게 보여주지
-- 이걸 마스킹 처리라고 함

-- EMPLOYEE 테이블에서 모든 직원의 사원명과 주민등록번호 뒤 6자리를 마스킹 처리해서 조회하기
-- 예시 => 이** 621335-1******
-- 1단계, 내가 출력해야 하는 모양새 : EMP_NAME, EMP_NO, 얘를 그대로 출력하고싶은게 아니고 첫번째는 앞글자만, 두번째는 8글자까지만 출력하고 싶음
-- 2단계, SUBSTR 적용, SUBSTR(EMP_NAME, 1, 1), SUBSTR(EMP_NO, 1, 8), 내가 보여주고싶은만큼만 추출해낼수있음
-- 3단계, 뒤에 * 채워넣어주기, RPAD이용
SELECT
       SUBSTR(EMP_NAME, 1, 1)
     , SUBSTR(EMP_NO, 1, 8)
  FROM
       EMPLOYEE;

SELECT
       RPAD(SUBSTR(EMP_NAME, 1, 1), 4, '*')
       -- 10:04 여기서는 한글 2Byte로 쓰이는데, 기본적으로는 3Byte로 처리됨, 오라클 함수마다 다르게 처리?
     , RPAD(SUBSTR(EMP_NO, 1, 8), 14, '*')
  FROM
       EMPLOYEE;
-- 앞에서 배운 두개 섞어서 마스킹 처리 할 수 있음, 자르고 채우기
-- 자바스크립트에 넘어가면 또 있음, 보통은 뒷단에서 처리하는게 좋고, 자바에서 처리하는것보다는 앞단에서 자바스크립트로 처리하는것이 데이터 효율적으로 처리할 수 있음
-- 문자열데이터이기때문에 자바에서 처리하는것은 좀 그렇슴
-- 실제로는 데이터 암호화되어서 저장되어있음

--------------------------------------------------

/*
 * LTRIM / RTRIM
 * 
 * - LTRIM / RTRIM(STR, 제거하고자하는 문자)
 * : 문자열의 왼쪽 또는 오른쪽에서 제거하고자 하는 문자들을 찾아서 제거한 나머지 문자열을 반환
 * 
 * 결과값은 CHARACTER타입으로 반환(문자? 문자열?)
 * 
 */

SELECT
       LTRIM('      K   H')
  FROM
       DUAL;
-- 인자 전달 안하면 공백문자만 없애줌

SELECT
       LTRIM('123123KH123', '123')
  FROM
       DUAL;
-- 앞에 붙어있던 123 시리즈가 다 날아감

--------------------------------------------------

-- 지금 자주 쓰는 것만 쓰고 있음

/*
 * TRIM
 * 
 * - TRIM(BOTH / LEADING / TRAILING '제거하고자하는문자' FROM STR)
 * : 문자열의 앞 / 뒤 / 양쪽에 있는 문자를 제거한 나머지 문자열을 반환
 * 
 * 결과값은 CHARACTER
 * BOTH / LEADING / TRAILING은 생략 가능 참고로 생략 시 기본값은 BOTH
 * 
 */
SELECT
       TRIM('    K    H    ')
  FROM
       DUAL; -- BOTH

SELECT
       TRIM(LEADING 'Z' FROM 'ZZZKHZZZ')
  FROM
       DUAL; -- LEADING은 LTRIM이랑 같음, 앞쪽

SELECT
       TRIM(TRAILING 'Z' FROM 'ZZZKHZZZ')
  FROM
       DUAL; -- TRAILING은 RTRIM이랑 같음, 뒤쪽

--------------------------------------------------

/*
 * 자바에서 대소문자 바꾸던거
 * LOWER / UPPER / INITCAP
 * 
 * - LOWER(STR)
 * : 다 소문자로
 * 
 * - UPPER(STR)
 * : 다 대문자로
 * 
 * - INITCAP(STR)
 * : 각 단어마다 앞글자만 대문자로 변경
 * 
 * 10:13 사실 여기서 바꾸는게 좋다.. 자바에서 말고/???
 * 
 * 결과값은 모두 CHARACTER타입으로 반환
 * 
 */
SELECT
       LOWER('HELLO WORLD')
  FROM
       DUAL;

SELECT
       UPPER('hello world')
  FROM
       DUAL;

SELECT
       INITCAP('hello world')
  FROM
       DUAL; -- 띄어쓰기 하면 첫글자를 대문자로 바꿔줌

--------------------------------------------------

-- 아 이런게 있구나, 아 이렇게 나오는거나 이정도만 알자

/*
 * CONCAT
 * 
 * - CONCAT(STR1, STR2)
 * : 전달된 두 개의 인자를 하나로 합친 결과를 반환
 * 
 * 반환타입은 CHARACTER
 * 
 */
SELECT CONCAT('경실련 하이텔', '정보교육원') FROM DUAL;
-- 사실 안좋음 연결연산자가 더 편함

-- SUBSTR INSTR LOWER UPPER 네개정도 기억해두자

--------------------------------------------------

/*
 * REPLACE
 * 
 * - REPLACE(STR, 찾을문자, 바꿀문자)
 * : STR로부터 찾을문자를 찾아서 바꿀문자로 바꾼 문자열을 반환
 * 결과값은 CHARACTER타입
 * 
 * 항상 좋음! 이것도 기억해두자
 * 
 */
SELECT
       REPLACE('서울시 중구 남대문로 120 대일빌딩', '대일빌딩', '그레이츠 청계')
  FROM
       DUAL;

SELECT
       EMAIL -- 메일 주소에서 회사 도메인이 바뀔 수 있지, 기존의 데이터값은 바꾸지 않고 조회할때만 바꿔주고싶음
     , REPLACE(EMAIL, 'kh.or.kr', 'iei.co.kr') -- REPLACE를 쓰면 실제 데이터는 바꾸지 않고 조회할 수 있음
  FROM
       EMPLOYEE;

-- 문자열 함수 끝!

--------------------------------------------------

-- 숫자 연산하기
-- 10:23 ???
-- 자바는 실수처리를 부동소수점 방식을 씀, 더블이 8바이트인데 제일 앞은 부호비트, 3칸(바이트)이 정수, 뒤쪽이 실수부
-- 1바이트당 8비트니까 2의 -1승 이런식으로 실수값을 저장함, 값 표현이 정확하지 않고 근사치를 저장함
-- 자바에서 실수연산은 근사치와 근사치의 연산이므로 정확하지 않을 수 있음, 그래서 기본 실수자료형으로 연산을 하지 않는 것이 원칙임
-- 이걸 어떻게 처리함? 자바 API중에 실수 연산할때 처리하는 클래스가 있고, 모든 연산을 DB에서 처리하면 자바에서 연산을 안해도 되니까..
-- 어차피 데이터 저장을 DB에서 할거니까 여기에서 다룰것임
-- 실수연산 중점적으로??? MATH 클래스보다 여기에서 처리하는게 더 좋다
/*
 * MOD
 * 
 * - MOD(NUMBER1, NUMBER2) ???
 * 
 */
SELECT
       MOD(10, 3)
     , MOD(-10, 3) -- 음수도 되고
     , MOD(10.8, 3) -- 실수도 됨
  FROM
       DUAL;

/*
 * ROUND
 * 
 * - ROUND(NUMBER, 위치) : 반올림 처리해주는 함수
 * 
 * 위치 : 소수점 아래 N번째 위치를 지정할 수 있음
 * 생략도 가능, 생략 시 기본값은 0
 * 
 */
SELECT
       ROUND(123.456)
     , ROUND(123.456, 1) -- 두번째 인자를 전달하면 소수점 아래 몇번째를 ???
     , ROUND(123.456, 2)
     , ROUND(123.456, -1) -- 음수도 가능, 음수는 정수부로 넘어감
     , ROUND(123.456, -2)
  FROM
       DUAL;
-- 우리가 많이 쓰는건 반올림, 지정 가능하니까, 올림은 잘 안 쓰고.. 버림은 쓸일이 있을지도?

--------------------------------------------------

/*
 * FLOOR
 * 
 * - FLOOR(NUMBER) 소수점 아래의 수를 무조건 버림처리해주는 함수
 * 
 * CEIL
 * 
 * - CEIL(NUMBER) 소수점 아래의 수를 무조건 올림처리해주는 함수
 * 
 * ROUND처럼 소수점 자리를 지정해서 처리할 수 없음
 * 소수점 자리를 지정하고싶으면 추가로 뭘 덧붙여야 해서 번거로움
 * -- 실제로 자바에서 뭔가 DECIMAL이라는 클래스가 처리하는 방식???
 * 한자리를 버리게 소수점 자리수를 바꿈 --> FLOOR(123.45 * 10) / 10
 * 
 */
SELECT
       FLOOR(123.45 * 10) / 10
  FROM
       DUAL;

SELECT CEIL(123.456) FROM DUAL;

--------------------------------------------------

-- 어제 못했던거 해보자
-- 각 직원별로 고용일로부터 오늘까지의 근무 일수 조회 + 이름조회
SELECT
       EMP_NAME
     , SYSDATE - HIRE_DATE -- 어제 이거 일수단위라고 얘기함, 오늘날짜에서 근무일수 뺀거, 근데 지저분함, 시분초까지 연산하니까
  FROM
       EMPLOYEE;
-- 오늘 배웠다! 버림 처리하면됨, 일자를 올림처리하지는 않으니까
SELECT
       EMP_NAME
     , CONCAT(FLOOR(SYSDATE - HIRE_DATE), '일') "근무일자"
  FROM
       EMPLOYEE;
-- 여기서 17년 이상 일한 사원만 조회하고싶다면?
SELECT
       EMP_NAME
     , CONCAT(FLOOR(SYSDATE - HIRE_DATE), '일') "근무일자"
  FROM
       EMPLOYEE
 WHERE
       FLOOR(SYSDATE - HIRE_DATE) > 365 * 17; -- 365일 곱하기 17년 해서 더 많은 애들!

--------------------------------------------------

/*
 * TRUNC
 * - TRUNC(NUMBER, 위치) : 위치지정이 가능한 절삭처리 함수
 * 버림처리랑은 다름! 소수점을 버리는게 아니라 삭제의 느낌, 잘라버림
 * 
 */
SELECT
       TRUNC(123.456, 2)
  FROM
       DUAL; -- 연산 이런거 안하고 그냥 버려버리는거라 속도가 빠름

-------------------------------------------------

-- 날짜 ㄱㄱ
/*
 * < 날짜 관련 함수 >
 * 오라클에서 날짜를 저장하는 자료형 2개
 * 
 * DATE 타입 : 년, 월, 일, 시, 분, 초를 모두 포함한 자료형
 * TIMESTAMP <- 얘는 나중에
 * 
 */
SELECT
       SYSDATE -- 현재시간을 반환받고싶을때
     , SYSTIMESTAMP -- 이런것도 있음! DATE랑 TIMESTAMP 두가지, 오라클에서 시간 다룰 때 자료형 두가지
     -- 일반적으로는 DATE 타입을 많이 사용함, 이유는 여러가지
     -- 오라클이 DBMS 1짱^^! 역사가 깊고 오래되고 많이 쓰임
     -- 처음 나왔을때는 TIMESTAMP가 없고 DATE로 구축이 되어있음
     -- TIMESTAMP는 DATE랑 호환이 안됨, 대부분의 일반적인 날짜와 시간은 DATE가 년월일시분초까지 표현해서..
     -- 기본적으로 얘한테 다 맞춰져있음
     -- 자바에서 IMPORT할때 두개였음, SQL이 DATE에 맞춰진거였음??
     -- 데이터 크기가 작음
     -- ??? TIMESTAMP가 훨씬 더 세분함, 나노초까지 저장함(?밀리초아님?), 정밀한 시간 측정할 때 사용, 일반적으로 사용하지는 않고
     -- 일반적인 상황에서는 DATE 타입
     -- 1000 밀리초가 1초인데 DATE는 표현이 안됨, TIMESTAMP는 밀리초 표기함, 기준시 표현도 함(시스템 기준으로 +0900)
  FROM
       DUAL;

-- MONTHS_BETWEEN(DATE1, DATE2) : 두 날짜사이의 개월 수 반환(NUMBER) (몇개월 차이인지, 너무 먼 미래를 넣으면 음수가 나올수도 있음, 2800년이라든가...?)
-- EMPLOYEE테이블로부터 각 사원 사원명, 고용일로부터 근무일수(이건 개월수로 따지면 골아픔, 윤달도 있고 2월도 있고 30일도 있고 31일도 있고 계산하기 복잡함 --> 이걸 함수로 만들어줌), 근무개월 수 조회
SELECT
       EMP_NAME
     , FLOOR(SYSDATE - HIRE_DATE) || '일' AS "근무일수" -- CONCAT보다는 ||이게 편하지
     , FLOOR(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) || '개월' AS "개월수"
  FROM
       EMPLOYEE;

-- ADD_MONTHS(DATE, NUMBER) : 특정날짜에 해당 숫자만큼의 개월 수를 더한 날짜(DATE로반환)
SELECT
       ADD_MONTHS(SYSDATE, 4)
  FROM
       DUAL;

-- NEXT_DAY(DATE, 요일) : 특정날짜에서 가장 가까운 요일을 찾아 그날짜를 반환
SELECT
       NEXT_DAY(SYSDATE, '금요일')
     , NEXT_DAY(SYSDATE, '금')
     , NEXT_DAY(SYSDATE, 6) -- 1 : 일요일, 2 : 월요일, 3 : 화요일 .. 7 : 토요일
  FROM
       DUAL;
-- FRI 이런거 쓰러면 언어변경해야함

-- 언어변경 ALTER SESSION SET NLS_LANGUAGE = AMERICAN; // KOREAN
-- 하지마세요! 같은 DB 쓰고있어서 다 바뀌어버립니다

-- LAST_DAY(DATE) 날짜를 받아서 해당 날짜가 있는 달의 마지막날짜를 반환
SELECT
       LAST_DAY(SYSDATE)
  FROM
       DUAL;

--------------------------------------------------

/*
 * 연도끼리 비교해야하는 상황, 연도를 뺀다든가.. 날짜에서 추출을 함
 * ☆EXTRACT : 년도 또는 월 또는 일정보를 추출해서 반환(NUMBER타입)
 * 
 * - EXTRACT(YEAR FROM DATE) : 년도만 추출
 * - EXTRACT(MONTH FROM DATE) : 월만 추출
 * - EXTRACT(DAY FROM DATE) : 일만 추출
 * 
 */
-- EMPLOYEE테이블에서 사원명 입사년도 입사월 입사일 --> 이걸 각각 다르게 조회할 수 있음
-- HIRE_DATE가 입사 연월일 정보를 다 가지고 있음
SELECT
       EMP_NAME
     , EXTRACT(YEAR FROM HIRE_DATE) AS "년도"
     , EXTRACT(MONTH FROM HIRE_DATE) AS "월"
     , EXTRACT(DAY FROM HIRE_DATE) AS "일"
     , EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)
  FROM
       EMPLOYEE
 ORDER
    BY
       "년도", "월", "일"; -- 이거 이용해서 ORDER BY 절 써서 입사년도로 줄세우기도 가능

-- 은근 쏠쏠 쓸일이 많음, 이친구는 기억해두자, 활용도가 높음

--------------------------------------------------

/*
 * < 형변환 함수 >
 * 오라클 DBMS도 저장할 자료형이 각각 따로따로 있음, 이것들을 면환할 수 있음
 * 
 * NUMBER / DATE => CHARACTER
 * 
 * - TO_CHAR(NUMBER/DATE, 포맷) : 숫자 또는 날짜 데이터를 문자데이터타입으로 반환
 * 
 */
SELECT
       1234 -- NUMBER 타입, 색깔만 봐도 티남, 파란색? 넘버라는 뜼
     , TO_CHAR(1234) -- 보여지는건 똑같이? 조금 차이남. 1234지만 숫자는 1,234 자리수 끊어서 보여줌, 문자로 변환하니 그냥 1234로 보여줌
     , TO_CHAR(1234, '000000') -- 포매팅을 같이 전달할 수 있음, 두번째 인자로 0을 보낼수 있음, 빈 자리수를 0으로 채워줌 -- 자리수보다 큰 공간을 0으로 채움
     , TO_CHAR(1234, '99999') -- 자리수보다 큰 공간을 공백문자로 채움(티가 안나는것처럼 보임)
     , TO_CHAR(1234, 'L00000') -- 대문자 L을 붙이면? 설정된 나라(LOCAL)의 화폐단위
     , TO_CHAR(1234, '$99999') -- 달러 표시도 붙일 수 있음
     -- 11:18 실제 넘버 데이터값이 붙어있지 않음, DBEAVER에서 조회할 때 이렇게? 나중에 하고싶을때는 어떻게?
     , TO_CHAR(12341234, 'L999,999,999,999')
  FROM
       DUAL;

--------------------------------------------------

-- 날짜를 바꾸는 문자로 경우가 더 많음!
-- DATE(년월일시분초) => CHARACTER
SELECT
       SYSDATE -- 기본적으로 DATE로 반환해줌, DATE 형식
     , TO_CHAR(SYSDATE) -- 25/08/26표시형식이 달라짐, 이걸 내가 원하는 형태로 바꿀 수 있음
     , TO_CHAR(SYSDATE, 'YYYY-MM-DD') -- 자바에서 심플데이트포맷 생각
     , TO_CHAR(SYSDATE, 'PM HH:MI:SS') -- PM 오전 / 오후출력
     , TO_CHAR(SYSDATE, 'HH24:MI:SS') -- 24시간 표기형식
     , TO_CHAR(SYSDATE, 'MON DY, YYYY') -- 월, 요일, 년도
  FROM
       DUAL;
-- 이건 실제로 많이 씀, 회원가입일, 게시글 작성일 등 날짜를 저장함, 실제로 출력해줄땐 이쁜모양으로 바꿔서 출력해주니까 이걸 써서 모양을 바꿔서 출력해줌

--------------------------------------------------

-- 날짜 데이터는 웬만해선 DB단에서 해결하고 가야함, 함수파트에서 제일 쏠쏠한 친구
-- 년도로 쓸 수 있는 포맷 Y2K문제
-- 11:30
-- 컴퓨터가 만들어진건 1900년대, 2000년으로 넘어가면 컴퓨터는 이게 뭔지 몰라, 지구상의 컴퓨터는 다 멈춰버릴거야 이런 문제
-- 말도안되는 소리긴 했는데 실제로 그랬음, 왜냐하면 1900년대면 00년이면 1900년으로 표시했겠지, 처음 컴퓨터 날짜 시스템을 만들 때 2000년대를 생각 안하고 만들었음
-- 1999년 12월 31일 마지막 시간이 넘어가면? 1900년으로 되면?
-- RRRR은 1900년대에 2000년대로 넘어가면 생길 문제를 해결하기 위해서 나온 친구
-- 네자리를 쓸 때는 별 차이가 없고, 두자리를 쓸 때 나옴, 상황에 따라 연도를 다르게 해석함
-- 0-49는 앞자리를 20이라고 생각함, 2000년부터 2049년까지
-- 50-99는 앞자리를 19라고 생각함, 1950년부터 1999년까지
-- YYYY는 항상 2000년대, 지금 우리..!
-- 나중에 뭔가 일어날수도?
SELECT
       TO_CHAR(SYSDATE, 'YYYY') -- YEAR, 단순히 연도 네자리, 현재 세기를 표시함(50을 넣으면 2050년, 90을 넣으면 2090)
     , TO_CHAR(SYSDATE, 'RRRR') -- ROUND YEAR, 현재는 차이가 없는데 억지로 차이를 만들어보자
     , TO_CHAR(TO_DATE('26-95', 'DD-YY'), 'YYYY')
     , TO_CHAR(TO_DATE('26-95', 'DD-RR'), 'YYYY') -- 두자리 써야 구분이 감
     , TO_CHAR(SYSDATE, 'YEAR') -- TWENTY TWENTY-FIVE로 출력됨, 힙스터?
  FROM
       DUAL;

-- 월에 쓸수있는 포맷
SELECT
       TO_CHAR(SYSDATE, 'MM') -- 08
     , TO_CHAR(SYSDATE, 'MON') -- 8월, 시스템에 따라서, 한글이라서 이렇게 나옴, 영어라면 3글자로
     , TO_CHAR(SYSDATE, 'MONTH') -- 8월, 영어라면 이게 풀네임으로 나올것
     , TO_CHAR(SYSDATE, 'RM') -- 힙스터용 로마숫자표기
  FROM
       DUAL;

-- 일에 쓸 수 있는 포맷
SELECT
       TO_CHAR(SYSDATE, 'DD') -- 무난함
     , TO_CHAR(SYSDATE, 'D') -- 안 무난함.. 무슨 의미임? 일요일 1부터 시작, 지금 화요일이니까 3
     , TO_CHAR(SYSDATE, 'DDD') -- 홍대병 친구들 D 이걸로 만족 못하죠? DDD 있음, 1월 1일로부터 며칠 지났는지
  FROM
       DUAL;
-- DD: 한달기준
-- D : 일주일기준(일요일부터)
-- DDD : 일년 기준(1월 1일부터)

-- 요일
SELECT
       TO_CHAR(SYSDATE, 'DAY')
     , TO_CHAR(SYSDATE, 'DY') -- 요일 뺄래, 영어는 DAY가 빠지겠지
  FROM
       DUAL;

-- 이걸 내맘대로 섞어쓰기도 하고 한글같은거 넣을수도 있음
SELECT
       EMP_NAME
     , HIRE_DATE -- 그냥 출력하면 안예쁨, 밀리초도 안나오고 구리네요, 이쁘게 꾸며야겠다!
     , TO_CHAR(HIRE_DATE, 'YYYY MM DD DY')
     , TO_CHAR(HIRE_DATE, 'YYYY"년" MM"월" DD"일" (DY)') -- 한글은 쌍따옴표로 묶어줌
  FROM
       EMPLOYEE;
-- 한글이 쓰고싶다? " "로 묶어주어야함

-- 날짜는 우리가 포매팅하는 경우가 굉장히 많음

--------------------------------------------------

/*
 * NUMBER / CHARACTER => DATE
 * 이것도 은근히 이런 경우 많음 엄청 진짜 많음, 왜냐하면 어제 우리 봤던 트립닷컴? 아고다 이런거 봤을 때...
 * 아고다에서 강릉을 간다고 할 때 날짜를 전달함, 예약하면 예약 내역에 이게 들어가야함, 이게 내가 보는 2025년 9월 6일 이렇게 그대로 갈 수 없음, 년도, 월, 숫자 따로가서 들어가서 하나로 합쳐져야함
 * 문자열로 넘어갈수도 있고, 숫자로 넘어갈수도 있지, 저장할때는 날짜로 바꿔서 저장해줘야함
 * 
 * - TO_DATE(NUMBER, CHARACTER, 포맷) : 숫자/문자를 날짜로 변환(DATE로반환)
 * 
 */
SELECT
       20250826 -- 오늘 날짜 썼는데 20,250,826으로 나옴, 정수로 인식함
     , TO_DATE(20250826)-- 날짜로 바꾸고 싶으면 TO_DATE로 감싸줌
     , TO_DATE('001212') -- 무조건 오늘 날짜 넣는 게 아님, 이럴수도 있지 001212로 입력하면? 근데 정수라서 앞이 00이라서 앞이 날아가버림, 사실상 1212밖에 없으니까 연도인지 월인지 알 수 없음, 얘를 따옴표로 묶어서 '001212', 문자데이터로 만들어야 날짜로 변환할 수 있음, 00이 살아있음
     , TO_DATE('980607') -- 이거 1998인데 2098을 하고싶다면? 뒤에 형식을 지정해줘야함
     , TO_DATE('980607', 'YYMMDD')
  FROM
       DUAL;

--------------------------------------------------

-- 문자를 숫자로 바꿔보자
/*
 * CHARACTER => NUMBER
 * 
 * - TO_NUMBER(CHARACTER, 포맷) : 문자를 숫자형으로 변환(NUMBER로반환)
 * 
 */
SELECT
       '01234' -- 문자로 쓰고싶은게 아니라 숫자로 쓰고싶음 --> TO_NUMBER로 감쌈
     , TO_NUMBER('01234') -- ???
  FROM
       DUAL;

-- 오라클이 똑똑함, 123 + 456이 보고싶음, 정수끼리 더한 결과 당연히 나오는건데
-- 123이 '123'일수도 있지? '123' + '456' 이면 정수랑 정수로 알아서 더해버림, 멍청한거야 똑똑한거야?
-- 123456 으로 만들고 싶으면 '123' || '456'
SELECT
       '123' + '456'
  FROM
       DUAL;

SELECT
       '11,000' + '20,000' -- 이건 못해줌, 쉼표가 들어가는 순간 정수가 아니라 문자열이 됨
  FROM
       DUAL; -- 이건 불가능

-- 이럴 때 얘를 숫자로 바꿈, 9를 이용한 포매팅 형식 이용
-- 11:49
SELECT
       TO_NUMBER('44,000', '99,999') + TO_NUMBER('20,000', '99,999')
  FROM
       DUAL;

--------------------------------------------------

-- 유용한 친구~ 어제 해결이 안됐던 이야기
/*
 * < NULL 처리 함수 >
 * 
 * NVL(컬럼명, 해당 컬럼값이 NULL값일 경우 반환할 결과값)
 * 
 */
SELECT
       EMP_NAME
     , BONUS -- 보너스가 있는 사람만 값이 나오고, 보너스가 없는 사람은 NULL값이 나옴
     -- 조회할 때 NULL이라고 보여줄 수는 없음, 웹사이트 이용할때 본적 있나요? 은근 꽤 있음, 기억을 못할 뿐, 이건 개발자의 실수
     -- 일반인은 널이 있다는 사실조차 몰라야함
     , NVL(BONUS, 0)
  FROM
       EMPLOYEE;

-- 널처리함수가 있으면 어제 해결하지 못한 문제를 해결할 수 있음
-- 보너스 포함 연봉조회
SELECT
       EMP_NAME
     , (SALARY + SALARY * BONUS) * 12 -- 보너스 컬럼이 널이면 산술연산했을때 널이 나옴, 연봉이 널이면 이상하잖아
     , (SALARY + SALARY * NVL(BONUS, 0)) * 12
     , DEPT_CODE -- 부서코드를 담는 컬럼, 부서 배치가 안된 사람도 있음, NULL이라고 보여주기도 아리까리하니까 널처리함수 이용
     , NVL(DEPT_CODE, '부서 없음')
  FROM
       EMPLOYEE;

-- 널처리함수 좋당~ 너무 좋아서 2도 나옴
-- NVL2(컬럼명, 결과값1, 결과값2)
-- 해당 컬럼에 값이 존재할 경우 결과값 1을 반환
-- 해당 컬럼에 값이 null값일 경우 결과값 2를 반환
SELECT
       EMP_NAME
     , DEPT_CODE -- 부서코드 있는친구와 없는친구가 있다
     , NVL2(DEPT_CODE, '부서 배치 완료', '부서없음') -- 값이 있으면 두번째 인자로, 값이 NULL이면 세번째 인자로 조회됨
  FROM
       EMPLOYEE;

-- 우와 좋당~ 널 하는거 하나 더!
-- NULLIF(비교대상1, 비교대상2)
-- 두 개의 값이 동일할경우 NULL을 반환
-- 두 개의 값이 동일하지 않을 경우 비교대상1을 반환
SELECT
       NULLIF('1', '1')
     , NULLIF('1', '2')
  FROM
       DUAL;

----------------------------------------

/*
 * < 선택함수 >
 * 
 * DECODE(비교대상(컬럼명/산술연산/함수식), 조건값1, 결과값1, 조건값2, 결과값2...결과값); 선생님의 MOST FAVORITE 함수래요
 * 맨 마지막 결과값이 default 역할
 * 
 * - 자바에서의 switch문과 유사
 * switch(비교대상) {
 * case 조건값1 : 결과값1;
 * case 조건값2 : 결과값2;
 * default : 결과값
 * }
 * 
 */

-- EMPLOYEE테이블 사원명, 성별
SELECT
       EMP_NAME
     , SUBSTR(EMP_NO, 8, 1) -- 성별을 나눌 수 있음, 이걸 1, 2로 조회하고 싶은게 아니고 남성, 여성 이렇게 조회하고 싶음 --> 이럴 때 사용하는게 DECODE
     -- SUBSTR 결과가 1 아니면 2로 나옴
     , DECODE(SUBSTR(EMP_NO, 8, 1), -- 지금은 함수식을 넣었지만 컬럼명, 산술연산, 다른 함수 등 DECODE의 첫번째 인자로 뭐든지 들어갈 수 있음
       1, '남성',
       2, '여성',
       '성별 선택 안함') AS "성별" -- 원래 한줄로 씁니다. 보기 편하게 이렇게 써봤어요
       -- 12:10 맨 마지막이 default 역할?????????????????
  FROM
       EMPLOYEE;

-- 급여에 물가반영해서 조회하고싶음
-- 직원들의 급여를 인상시켜서 조회
-- 직급코드(JOB_CODE)가 'J7'인 사원들의 급여는 15% 인상해서 조회
-- 직급코드가 'J6'인 사원들의 급여는 20% 인상해서 조회
-- 직급코드가 'J5'인 사원들의 급여는 30% 인상해서 조회
-- 나머지 직급인 사원들의 급여는 5% 인상해서 조회
SELECT
       EMP_NAME
     , SALARY
     , JOB_CODE -- 12:19 ???
     , DECODE(JOB_CODE, 'J7', (SALARY + SALARY * 0.15)
     				  , 'J6', (SALARY + SALARY * 0.2)
     				  , 'J5', (SALARY + SALARY * 0.3)
     				  , (SALARY + SALARY * 0.05)) "인상 후 급여"
  FROM
       EMPLOYEE;
-- 마치 switch문 같군요, 편하고 쏠쏠하구 쓰기도 편하고 좋다
-- 12:24 실제로 뭐 만들고 개발할때 switch문 잘 안씀, 거의 DB에서 DECODE로 처리하고 자바에서는 안씀?
-- 삼항연산자로 해결?

--------------------------------------------------

/*
 * CASE WHEN THEN 구문
 * 
 * - DECODE랑 비교했을 때 DECODE는 동등비교만 수행
 *   CASE WHAN THEN (동등비교 말고도)다양한 조건식을 기술 가능(대소비교, BETWEEN AND 등)
 * DECODE에 비해서 쓸 게 많음
 * 
 * [ 표현법 ] CASE로 시작해서 END로 끝남
 * CASE
 * 		WHEN 조건식1 THEN 결과값1
 * 		WHEN 조건식2 THEN 결과값2
 * 		...
 * 		ELSE 결과값(switch면 default, if면 else처럼)
 * END
 * 
 */

-- 12:28 중요한거 뭐임?
SELECT
       EMP_NAME
     , CASE
     	WHEN SUBSTR(EMP_NO, 8, 1) = '1' THEN '남성'
     	WHEN SUBSTR(EMP_NO, 8, 1) = '2' THEN '여성' -- 동등비교를 한다면 DECODE에 비해 쓸 게 많음
     	ELSE '성별선택안함'
	   END "성별"
  FROM
       EMPLOYEE;

-- 단일행함수는 여기까지~ 외우지 말고 한번 써봤다~ 필요하면 찾아쓰기, 사용법은 한번은 써봐야 아니까 쭉 써봤음
-- 사실 단일행함수 별로 안중요함

--------------------------------------------------

------------------------- < ☆그룹 함수★ > -------------------------

-- 다섯개 할건데 그냥 외우세요 별로 어렵지도 않아요
/*
 * N개의 값을 읽어서 1개의 결과를 반환(하나의 그룹별로 함수 실행결과를 반환)
 * 
 */
SELECT
       SALARY
  FROM
       EMPLOYEE;
-- 직원들의 급여의 합계는 얼마인가? 23명의 급여의 합을 알아내고싶음, 이때 필요한게 그룹함수
-- 계산기를 켤 수는 없잖아요 ㅎ 23명이면 누를만하지만 대기업이면 어떡해요 사원수가 1000명이 넘어.. 급여가 연봉협상하면 바뀔거고 나가면빼고 들어오면 넣고.. 어려워
-- 1. SUM(숫자타입) : 해당 컬럼값들의 총 합계를 반환해주는 함수
-- 전체 사원의 총 급여합계(SALARY컬럼 다 합치면 얼마지?)
-- SUM의 인자로 SALARY를 넣음
SELECT
       SUM(SALARY) -- 회사관리에인건비가많이들어감을깨달을수있음
  FROM
       EMPLOYEE;

-- 어제 배운거랑 섞어서 이런거 해보자
SELECT
       EMP_NAME
     , EMAIL
  FROM
       EMPLOYEE;

-- 이메일에 0이 들어가는 사원들의 총 급여합
SELECT
       SUM(SALARY)
  FROM
       EMPLOYEE
 WHERE
       EMAIL LIKE '%0%'
-- 또 이중에서 부서코드가 D5인 친구들만
   AND
       DEPT_CODE = 'D5';

--------------------------------------------------

-- SUM은 중요했고, 안중요한친구 트리오
-- 2. AVG(숫자타입) : 해당 컬럼값들의 평균값을 구해서 반환
-- 전체사원들의 급여 평균구하기
SELECT
       AVG(SALARY) -- 23개의 평균을 구하는데 결과는 두개가 나올 수 없음 결과는 하나만 나옴
     , ROUND(AVG(SALARY))-- 두개를 같이 조회할수는 없지만 이건 가능
  FROM
       EMPLOYEE;

-- 3. MIN(ANY) : 해당 컬럼값들 중 작은 값 반환
SELECT
       MIN(SALARY) "제일 작은 급여"
     , MIN(EMP_NAME) "제일 이름이 빠른사람" -- 오름차순 했을때 제일 앞에있는것
     , MIN(HIRE_DATE) "제일 빠른 입사일"
  FROM
       EMPLOYEE;
-- ANY라서 숫자만 들어갈 수 있는게 아님, 이름을 넣을수도 있음, 날짜가 들어갈수도 있음

-- 실과 바늘 시리즈, MIN이 있으면 MAX도 있겠다
-- 4. MAX(ANY) : 해당 컬럼값들 중 가장 큰 값 반환
SELECT
       MAX(SALARY) "가장 높은 급여"
     , MAX(EMP_NAME) "가장 느린 이름"
     , MAX(HIRE_DATE) "가장 늦은 입사일"
  FROM
       EMPLOYEE;
-- MIN MAX는 숫자만 넣을 수 있는게 아니고 ANY TYPE

-- 12:48 그룹함수중에서 제일잘쓰고제일유용하고제일중요한거???
-- 5. COUNT(* / 컬럼명 / DISTINCT 컬럼명) : 행 개수 세서 반환
SELECT * FROM EMPLOYEE; -- 23행인데, 이게 만약에 엄청 많다면? 사람이 세기 힘들어진다
-- COUNT(*) : 조회 결과에 해당하는 모든 행 개수를 다 세서 반환
SELECT
       COUNT(*)
  FROM
       EMPLOYEE;

-- * 말고 컬럼명을 적을 수 있음, 지금 보너스 받는/받지않는 사원이 나뉘어져있음
-- 보너스를 받는 사원의 수
-- COUNT(컬럼명) : 제시한 컬럼값이 NULL이 아닌 행만 개수를 세서 반환
SELECT
       COUNT(BONUS) -- 컬럼명을 COUNT 함수의 인자로 전달함
  FROM
       EMPLOYEE;

SELECT
       COUNT(*)
  FROM
       EMPLOYEE
 WHERE
       BONUS IS NOT NULL; -- 이렇게 써도 결과는 같지만, COUNT를 이용해서 컬럼명만 쓰는 것이 편함

-- 현재 사원들이 속해있는 부서 개수
-- COUNT(DISTINCT 컬럼명) : 제시한 해당 컬럼값이 중복값이 존재할경우 하나로만 세서 반환
-- 14:05 COUNT 설명
SELECT
       DEPT_CODE -- 각각의 부서가 들어있고, 부서가 없는 사람도 있음, 이것을 세면 부서가 NULL이 아닌 친구를 셈
       -- 똑같은 부서가 있을수도 있지
       -- 현재 사원들이 속해있는 부서 개수
     , COUNT(DISTINCT DEPT_CODE)
  FROM
       EMPLOYEE;